# 701. Insert into a Binary Search Tree
搜索到空节点，记录`prev`节点，插入位置
``` java
TreeNode insertIntoBST(TreeNode root, int val) {
    if(root == null) return new TreeNode(val);
    if(root.val > val){
        root.left =  insertIntoBST(root.left,val);
    }else{
        root.right = insertIntoBST(root.right,val);
    }
    return root;
}
```
# 703. Kth Largest Element in a Stream
维护一个最小堆
# 704. Binary Search
使用内置的二分函数
# 705. Design HashSet
根据数据大小开数组
# 706. Design HashMap
根据数据大小开数组，赋初值为`-1`
# 707. Design Linked List
使用虚拟头结点
# 709. To Lower Case
数字转字符
> (char)(num+'0')

可以调用库函数
> str.toLowerCase()
# 710. Random Pick with Blacklist
随机出`n-len`的值，如果在黑名单，则对应到`n-len`之后，构造函数构造这个对应关系
>运用迭代器每次取出一个元素
# 712. Minimum ASCII Delete Sum for Two Strings
记忆化递归，也可以`dp`
``` java
for (int i = 1; i <= s1.length(); i++) {
    dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
}
for (int j = 1; j <= s2.length(); j++) {
    dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
}
for (int i = 1; i <= s1.length(); i++) {
    for (int j = 1; j <= s2.length(); j++) {
        if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
        else dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
    }
}
return dp[s1.length()][s2.length()];
```
# 713. Subarray Product Less Than K
考虑以某位置结尾的最左位置，记录全部的积
> 双指针
``` java
if (k <= 1) return 0;
int prod = 1, ans = 0, left = 0;
for (int right = 0; right < nums.length; right++) {
    prod *= nums[right];
    while (prod >= k) prod /= nums[left++];
    ans += right - left + 1;
}
```