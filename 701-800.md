# 701. Insert into a Binary Search Tree
搜索到空节点，记录`prev`节点，插入位置
``` java
TreeNode insertIntoBST(TreeNode root, int val) {
    if(root == null) return new TreeNode(val);
    if(root.val > val){
        root.left =  insertIntoBST(root.left,val);
    }else{
        root.right = insertIntoBST(root.right,val);
    }
    return root;
}
```
# 703. Kth Largest Element in a Stream
维护一个最小堆
# 704. Binary Search
使用内置的二分函数
# 705. Design HashSet
根据数据大小开数组
# 706. Design HashMap
根据数据大小开数组，赋初值为`-1`
# 707. Design Linked List
使用虚拟头结点
# 709. To Lower Case
数字转字符
> (char)(num+'0')

可以调用库函数
> str.toLowerCase()
# 710. Random Pick with Blacklist
随机出`n-len`的值，如果在黑名单，则对应到`n-len`之后，构造函数构造这个对应关系
>运用迭代器每次取出一个元素
# 712. Minimum ASCII Delete Sum for Two Strings
记忆化递归，也可以`dp`
``` java
for (int i = 1; i <= s1.length(); i++) {
    dp[i][0] = dp[i - 1][0] + s1.charAt(i - 1);
}
for (int j = 1; j <= s2.length(); j++) {
    dp[0][j] = dp[0][j - 1] + s2.charAt(j - 1);
}
for (int i = 1; i <= s1.length(); i++) {
    for (int j = 1; j <= s2.length(); j++) {
        if (s1.charAt(i - 1) == s2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
        else dp[i][j] = Math.min(dp[i - 1][j] + s1.charAt(i - 1), dp[i][j - 1] + s2.charAt(j - 1));
    }
}
return dp[s1.length()][s2.length()];
```
# 713. Subarray Product Less Than K
考虑以某位置结尾的最左位置，记录全部的积
> 双指针
``` java
if (k <= 1) return 0;
int prod = 1, ans = 0, left = 0;
for (int right = 0; right < nums.length; right++) {
    prod *= nums[right];
    while (prod >= k) prod /= nums[left++];
    ans += right - left + 1;
}
```
# 714. Best Time to Buy and Sell Stock with Transaction Fee
考虑两个状态的转移即可，在卖出去的时候减去手续费
# 715. Range Module
使用`treemap`
>`map[left]=right`
# 717. 1-bit and 2-bit Characters
如果是`1`则往后走两个，否则走一个，看能走到的位置
# 718. Maximum Length of Repeated Subarray
连续的数组，所以`dp`要考虑从对角线转移过来，途中记录最大值
# 719. Find K-th Smallest Pair Distance
桶排序的思想，把所有的差值个数记录下来，找第`k`大的元素

另外是二分的方法，排序后，查找有多少个小于`mid`
``` java
Arrays.sort(nums);
    int n = nums.length-1;
    int left = 0;
    int right = nums[n]-nums[0];
    while(left<right){
        int start = 0;
        int count = 0;
        int mid = left+(right-left)/2;
        for(int i = 0;i<=n;i++){
            while(start<=n && nums[i]-nums[start]>mid) start+=1;
            count+=i-start;
        }
        if(count<k){
            left = mid+1;
        }
        else{
            right = mid;
        }
    }
    return left;
}
```