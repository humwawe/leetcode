# 801. Minimum Swaps To Make Sequences Increasing
`dp[i][j]`，表示第`i`位是否交换
> 带条件推导，两个`if`都有可能算到
# 802. Find Eventual Safe States
判断是否存在环，`dfs`遍历看是否有已经访问到的

考虑拓扑排序，没有出度的点便是安全的，加入队列，持续更新
# 803. Bricks Falling When Hit
每次从第一行遍历看还剩多少，用总的减去剩的，或者从`hit`的点开始`dfs`，效率比较低

考虑并查集的思路，从后往前，每次能加入多少到并查集中
# 804. Unique Morse Code Words
将单词转码放入`set`中，返回`size`即可
# 805. Split Array With Same Average
可以用`dp`，考虑用`k`个数能组成的和，逆序有滚动数组的思想

采用`dfs`加剪枝
```` java
for(int i = 1; i <= len/2; i++){
    int remainder = sum * i % len;
    int target = sum * i / len;
    if(remainder == 0 && helper(A,0,i,target))
        return true;
}
public boolean helper(int[] A, int begin, int len, int target){
    if(len == 0) 
        return target == 0;
    if(target < len * A[begin])
        return false;
    for(int i = begin; i <= A.length - len; i++){
        if(i > begin && A[i] == A[i-1]) continue;
        if(helper(A, i+1, len-1, target- A[i]))
            return true;
    }
    return false;
}
````
# 806. Number of Lines To Write String
累加，加到`100`换行
# 807. Max Increase to Keep City Skyline
求出两个方向的天际线，遍历找不超过边际线的值
# 808. Soup Servings
考虑从四个选取中转换过来，另外注意到当`n`大于某个数，`a`先倒完的概率已经很大了，可以直接返回
> 概率题可以考虑递归
# 809. Expressive Words
将单词分段，在比较每个`word`是否满足
# 810. Chalkboard XOR Game
注意到异或为`0`则直接获胜，当异或不为`0`的时候且个数为偶数的时候，肯定能拿出一个使得其他的数异或不为`0`