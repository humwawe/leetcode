# 801. Minimum Swaps To Make Sequences Increasing
`dp[i][j]`，表示第`i`位是否交换
> 带条件推导，两个`if`都有可能算到
# 802. Find Eventual Safe States
判断是否存在环，`dfs`遍历看是否有已经访问到的

考虑拓扑排序，没有出度的点便是安全的，加入队列，持续更新
# 803. Bricks Falling When Hit
每次从第一行遍历看还剩多少，用总的减去剩的，或者从`hit`的点开始`dfs`，效率比较低

考虑并查集的思路，从后往前，每次能加入多少到并查集中
# 804. Unique Morse Code Words
将单词转码放入`set`中，返回`size`即可
# 805. Split Array With Same Average
可以用`dp`，考虑用`k`个数能组成的和，逆序有滚动数组的思想

采用`dfs`加剪枝
```` java
for(int i = 1; i <= len/2; i++){
    int remainder = sum * i % len;
    int target = sum * i / len;
    if(remainder == 0 && helper(A,0,i,target))
        return true;
}
public boolean helper(int[] A, int begin, int len, int target){
    if(len == 0) 
        return target == 0;
    if(target < len * A[begin])
        return false;
    for(int i = begin; i <= A.length - len; i++){
        if(i > begin && A[i] == A[i-1]) continue;
        if(helper(A, i+1, len-1, target- A[i]))
            return true;
    }
    return false;
}
````