# 801. Minimum Swaps To Make Sequences Increasing
`dp[i][j]`，表示第`i`位是否交换
> 带条件推导，两个`if`都有可能算到
# 802. Find Eventual Safe States
判断是否存在环，`dfs`遍历看是否有已经访问到的

考虑拓扑排序，没有出度的点便是安全的，加入队列，持续更新
# 803. Bricks Falling When Hit
每次从第一行遍历看还剩多少，用总的减去剩的，或者从`hit`的点开始`dfs`，效率比较低

考虑并查集的思路，从后往前，每次能加入多少到并查集中
# 804. Unique Morse Code Words
将单词转码放入`set`中，返回`size`即可
# 805. Split Array With Same Average
可以用`dp`，考虑用`k`个数能组成的和，逆序有滚动数组的思想

采用`dfs`加剪枝
```` java
for(int i = 1; i <= len/2; i++){
    int remainder = sum * i % len;
    int target = sum * i / len;
    if(remainder == 0 && helper(A,0,i,target))
        return true;
}
public boolean helper(int[] A, int begin, int len, int target){
    if(len == 0) 
        return target == 0;
    if(target < len * A[begin])
        return false;
    for(int i = begin; i <= A.length - len; i++){
        if(i > begin && A[i] == A[i-1]) continue;
        if(helper(A, i+1, len-1, target- A[i]))
            return true;
    }
    return false;
}
````
# 806. Number of Lines To Write String
累加，加到`100`换行
# 807. Max Increase to Keep City Skyline
求出两个方向的天际线，遍历找不超过边际线的值
# 808. Soup Servings
考虑从四个选取中转换过来，另外注意到当`n`大于某个数，`a`先倒完的概率已经很大了，可以直接返回
> 概率题可以考虑递归
# 809. Expressive Words
将单词分段，在比较每个`word`是否满足
# 810. Chalkboard XOR Game
注意到异或为`0`则直接获胜，当异或不为`0`的时候且个数为偶数的时候，肯定能拿出一个使得其他的数异或不为`0`
# 811. Subdomain Visit Count
遍历拆分即可
# 812. Largest Triangle Area
遍历三个点求最大面积
> `S=|ad＋be＋cf－af－bc－de| * 0.5`
# 813. Largest Sum of Averages
`dp`，`dp[i][k]`表示前`i`个分成`k`份时的最大值，预处理前缀和可以常数时间得到平均值
> `dp[i][k] = max(dp[i][k], dp[j][k - 1] + 1.0 * (sum[i] - sum[j]) / (i - j))`
# 814. Binary Tree Pruning
后续遍历，如果当前元素为`0`且左右子树为`null`，则删除节点

考虑子树是否包含`1`
``` java
return containsOne(root) ? root : null;

private boolean containsOne(TreeNode node) {
    if (node == null) return false;
    boolean a1 = containsOne(node.left);
    boolean a2 = containsOne(node.right);
    if (!a1) node.left = null;
    if (!a2) node.right = null;
    return node.val == 1 || a1 || a2;
}
```
# 815. Bus Routes
构建点到`bus`的图后`bfs`，如果构建点与点的关系会超时
# 816. Ambiguous Coordinates
相当于三重循环，先分逗号，再分点
# 817. Linked List Components
遍历链表看有多少个连续段在`set`中
# 818. Race Car
`bfs`容易超时，注意剪枝，位置和速度都要小于`2*target`

记忆化递归，如果在`2`的`n`次方减`1`则直接返回`n`，另外两种策略
1. 刚好大于`target`时返回
2. 刚好小于`target`时返回`i`步数，再往前
# 819. Most Common Word
对单词预处理然后统计个数

可以依次遍历，构造`word`
``` java
for (char c: paragraph.toCharArray()) {
    if (Character.isLetter(c)) {
        word.append(Character.toLowerCase(c));
    } else if (word.length() > 0) {
        String finalword = word.toString();
        if (!banset.contains(finalword)) {
            count.put(finalword, count.getOrDefault(finalword, 0) + 1);
            if (count.get(finalword) > ansfreq) {
                ans = finalword;
                ansfreq = count.get(finalword);
            }
        }
        word = new StringBuilder();
    }
}
```