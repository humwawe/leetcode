# 1601. Maximum Number of Achievable Transfer Requests
枚举所有可能，考虑某个`req`选或不选的情况
# 1603. Design Parking System
记录次数模拟
# 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period
按时间排序，用一个小时的滑动窗口统计是否有满足的

可以按人名为组把时间放入`list`，对时间排序后看是否存在`3`个一小时以内的
# 1605. Find Valid Matrix Given Row and Column Sums
贪心，第一行的和肯定小于所有列的和，因此每个位置取最小的，减去后，变成`n-1 * m`的子问题
# 1606. Find Servers That Handled Most Number of Requests
优先队列维护结束时间，`treeset`维护可用服务器，每到一个时间，从优先队列中弹出满足的服务器
# 1608. Special Array With X Elements Greater Than or Equal X
排序后，找到第一个大于等于该值的位置
# 1609. Even Odd Tree
层序遍历，把每层放到另一个队列中

可以考虑再出队循环`size`的时候判断
``` java
prev = level % 2 == 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
for (int i = 0; i < size; i++) {
    TreeNode poll = q.poll();
    if (level % 2 == 0) {
        if (poll.val % 2 != 1) return false;
        if (poll.val <= prev) return false;
        prev = poll.val;
    } else {
        if (poll.val % 2 != 0) return false;
        if (poll.val >= prev) return false;
        prev = poll.val;
    }
    if (poll.left != null) q.offer(poll.left);
    if (poll.right != null) q.offer(poll.right);
}
```
# 1610. Maximum Number of Visible Points
算角度然后双指针查找，因为可以旋转，考虑整个数组加`360`后接到后面
# 1611. Minimum One Bit Operations to Make Integers Zero
等价于用格雷码找自然数
# 1614. Maximum Nesting Depth of the Parentheses
只考虑左右括号
# 1615. Maximal Network Rank
遍历每两个点考虑其连接数，两者若相连则减`1`
# 1616. Split Two Strings to Make Palindrome
双指针判断是否回文，当不能构成的时候考虑中间部分各自是否能构成
# 1617. Count Subtrees With Max Distance Between Cities
位运算遍历所有子集，考虑是否连通及其距离，距离可以提前`Floyd`预处理
# 1619. Mean of Array After Removing Some Elements
排序去掉前面和后面的数求平均值
# 1620. Coordinate With Maximum Network Quality
遍历整数的点，求每个点的信号强度
# 1621. Number of Sets of K Non-Overlapping Line Segments
`dp[i][j][2]`，表示`i`位置`j`个线段，`0`表示不选（第`j`条线段的右端点不是`i`），`1`表示选（第`j`条线段的右端点是`i`）
 # 1622. Fancy Sequence
 本质可以看成前缀的计算，记录某个位置已经乘了多少加了多少，记为`a`，`b`，经过一段时间变为`x`，`y`，则过程中的乘和加`i`，`j`为
 ```
a*i=x => i=x/a
b*i+j=y => j=y-b*i
```
用`java`的大数可解，不过容易超时，因此考虑模运算下的逆元操作
