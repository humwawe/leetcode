# 101. Symmetric Tree
想象两棵树来比较
# 102. Binary Tree Level Order Traversal
记录每一个应该打印多少次

也可以用前序遍历，每次记录深度，将值放入对应的数组
# 103. Binary Tree Zigzag Level Order Traversal
思路与[102](#102-binary-tree-level-order-traversal)差不多
>设置一个标志位，根据标志位考虑怎样插入
# 104. Maximum Depth of Binary Tree
根据函数的语义递归求解
也可以使用`bfs`跟`dfs`
# 105. Construct Binary Tree from Preorder and Inorder Traversal
利用先序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 106. Construct Binary Tree from Inorder and Postorder Traversal
利用后序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 107. Binary Tree Level Order Traversal II
思路与[102](#102-binary-tree-level-order-traversal)差不多
> 最后放的时候放入最开始的位置即可
# 108. Convert Sorted Array to Binary Search Tree
取数组的中间元素作为根结点， 将数组分成左右两部分，对数组的两部分用递归的方法分别构建左右子树
# 109. Convert Sorted List to Binary Search Tree
记录长度，每次计算位置

或者可以用快慢指针来找到位置
``` java
ListNode slow = head,fast = head;
ListNode prev = new ListNode(0);
prev.next = head;
while(fast != null && fast.next != null){
    prev = prev.next;
    slow = slow.next;
    fast = fast.next.next;
}
TreeNode root = new TreeNode(slow.val);
root.right = sortedListToBST(slow.next);
prev.next = null;
root.left = sortedListToBST(head);
```
# 110. Balanced Binary Tree
不仅需要判断左右是否平衡，还需计算高度差，高度差可以每次递归计算
``` java
Math.max(depth(root.left),depth(root.right)) + 1;
```
因为要返回两个值，一个高度、一个是否是平衡树，因此可以考虑将两个值做为一体返回

也可以定义树的高度，递归，看每个节点是否满足平衡
# 111. Minimum Depth of Binary Tree
记录遍历到每个节点的深度，到叶子节点便与`min`比较
# 112. Path Sum
遍历每个值，注意叶子节点的条件是当前`sum`与该节点的值是否相等
# 113. Path Sum II
遍历所有路径，找到相同的即加入结果集，注意加入某个叶子后，要把该点再删除
# 114. Flatten Binary Tree to Linked List
递归，考虑左边已经flateen，插入root右边，并将左边至为空，再插入右边
# 115. Distinct Subsequences
递归超时，考虑动态规划（可以压缩空间、优化）
* 某个位置若相等，则为要或者不要的和
* 某个位置若不相等，则只能不要
# 116. Populating Next Right Pointers in Each Node
层次遍历，当每层最后一个元素设置的`next`为`null`
# 117. Populating Next Right Pointers in Each Node
跟[116](#116-populating-next-right-pointers-in-each-node)一样
# 118. Pascal's Triangle
递归求解
# 119. Pascal's Triangle II
第`i+1`项是第`i`项的倍数`(n-i)/(i+1)`
``` java
cur = cur * (rowIndex-i)/(i+1);
```
或者减少空间只用一个数组，从后往前累加
``` java
for (int i = 0; i <= rowIndex; i++) {
    for (int j = i; j >= 0; j--) {
        if (j == 0 || j == i)
            num[j] = 1;
        else
            num[j] = num[j] + num[j - 1];
    }
}
```
# 120. Triangle
可以考虑从倒数第二行开始向上`dp`，最后的就是结果
# 121. Best Time to Buy and Sell Stock
只能买卖一次，记录三个状态，未持有，买入，卖出

注意初始化
``` java
result[0][1] = -prices[0]
```
另外由于只买卖一次，可以记录当前位置之前买入最小值，然后当前卖出，保存最好的结果
# 122. Best Time to Buy and Sell Stock II
可以买卖无数次，所以有两个状态，持有和未持有

另外可以贪心，只要今天价格小于明天价格就在今天买入然后明天卖出