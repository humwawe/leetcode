# 101. Symmetric Tree
想象两棵树来比较
# 102. Binary Tree Level Order Traversal
记录每一个应该打印多少次

也可以用前序遍历，每次记录深度，将值放入对应的数组
# 103. Binary Tree Zigzag Level Order Traversal
思路与[102](#102-binary-tree-level-order-traversal)差不多
>设置一个标志位，根据标志位考虑怎样插入
# 104. Maximum Depth of Binary Tree
根据函数的语义递归求解
也可以使用`bfs`跟`dfs`
# 105. Construct Binary Tree from Preorder and Inorder Traversal
利用先序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 106. Construct Binary Tree from Inorder and Postorder Traversal
利用后序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 107. Binary Tree Level Order Traversal II
思路与[102](#102-binary-tree-level-order-traversal)差不多
> 最后放的时候放入最开始的位置即可
# 108. Convert Sorted Array to Binary Search Tree
取数组的中间元素作为根结点， 将数组分成左右两部分，对数组的两部分用递归的方法分别构建左右子树
# 109. Convert Sorted List to Binary Search Tree
记录长度，每次计算位置

或者可以用快慢指针来找到位置
``` java
ListNode slow = head,fast = head;
ListNode prev = new ListNode(0);
prev.next = head;
while(fast != null && fast.next != null){
    prev = prev.next;
    slow = slow.next;
    fast = fast.next.next;
}
TreeNode root = new TreeNode(slow.val);
root.right = sortedListToBST(slow.next);
prev.next = null;
root.left = sortedListToBST(head);
```
# 110. Balanced Binary Tree
不仅需要判断左右是否平衡，还需计算高度差，高度差可以每次递归计算
``` java
Math.max(depth(root.left),depth(root.right)) + 1;
```
因为要返回两个值，一个高度、一个是否是平衡树，因此可以考虑将两个值做为一体返回

也可以定义树的高度，递归，看每个节点是否满足平衡
# 111. Minimum Depth of Binary Tree
记录遍历到每个节点的深度，到叶子节点便与`min`比较
# 112. Path Sum
遍历每个值，注意叶子节点的条件是当前`sum`与该节点的值是否相等