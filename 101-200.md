# 101. Symmetric Tree
想象两棵树来比较
# 102. Binary Tree Level Order Traversal
记录每一个应该打印多少次

也可以用前序遍历，每次记录深度，将值放入对应的数组
# 103. Binary Tree Zigzag Level Order Traversal
思路与[102](#102-binary-tree-level-order-traversal)差不多
>设置一个标志位，根据标志位考虑怎样插入
# 104. Maximum Depth of Binary Tree
根据函数的语义递归求解
也可以使用`bfs`跟`dfs`
# 105. Construct Binary Tree from Preorder and Inorder Traversal
利用先序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 106. Construct Binary Tree from Inorder and Postorder Traversal
利用后序遍历结果找到根节点，然后将遍历中序找到索引，根据索引划分成左右子树的问题递归即可
# 107. Binary Tree Level Order Traversal II
思路与[102](#102-binary-tree-level-order-traversal)差不多
> 最后放的时候放入最开始的位置即可
# 108. Convert Sorted Array to Binary Search Tree
取数组的中间元素作为根结点， 将数组分成左右两部分，对数组的两部分用递归的方法分别构建左右子树
# 109. Convert Sorted List to Binary Search Tree
记录长度，每次计算位置

或者可以用快慢指针来找到位置
``` java
ListNode slow = head,fast = head;
ListNode prev = new ListNode(0);
prev.next = head;
while(fast != null && fast.next != null){
    prev = prev.next;
    slow = slow.next;
    fast = fast.next.next;
}
TreeNode root = new TreeNode(slow.val);
root.right = sortedListToBST(slow.next);
prev.next = null;
root.left = sortedListToBST(head);
```
# 110. Balanced Binary Tree
不仅需要判断左右是否平衡，还需计算高度差，高度差可以每次递归计算
``` java
Math.max(depth(root.left),depth(root.right)) + 1;
```
因为要返回两个值，一个高度、一个是否是平衡树，因此可以考虑将两个值做为一体返回

也可以定义树的高度，递归，看每个节点是否满足平衡
# 111. Minimum Depth of Binary Tree
记录遍历到每个节点的深度，到叶子节点便与`min`比较
# 112. Path Sum
遍历每个值，注意叶子节点的条件是当前`sum`与该节点的值是否相等
# 113. Path Sum II
遍历所有路径，找到相同的即加入结果集，注意加入某个叶子后，要把该点再删除
# 114. Flatten Binary Tree to Linked List
递归，考虑左边已经flateen，插入root右边，并将左边至为空，再插入右边
# 115. Distinct Subsequences
递归超时，考虑动态规划（可以压缩空间、优化）
* 某个位置若相等，则为要或者不要的和
* 某个位置若不相等，则只能不要
# 116. Populating Next Right Pointers in Each Node
层次遍历，当每层最后一个元素设置的`next`为`null`
# 117. Populating Next Right Pointers in Each Node
跟[116](#116-populating-next-right-pointers-in-each-node)一样
# 118. Pascal's Triangle
递归求解
# 119. Pascal's Triangle II
第`i+1`项是第`i`项的倍数`(n-i)/(i+1)`
``` java
cur = cur * (rowIndex-i)/(i+1);
```
或者减少空间只用一个数组，从后往前累加
``` java
for (int i = 0; i <= rowIndex; i++) {
    for (int j = i; j >= 0; j--) {
        if (j == 0 || j == i)
            num[j] = 1;
        else
            num[j] = num[j] + num[j - 1];
    }
}
```
# 120. Triangle
可以考虑从倒数第二行开始向上`dp`，最后的就是结果
# 121. Best Time to Buy and Sell Stock
只能买卖一次，记录三个状态，未持有，买入，卖出

注意初始化
``` java
result[0][1] = -prices[0]
```
另外由于只买卖一次，可以记录当前位置之前买入最小值，然后当前卖出，保存最好的结果
# 122. Best Time to Buy and Sell Stock II
可以买卖无数次，所以有两个状态，持有和未持有

另外可以贪心，只要今天价格小于明天价格就在今天买入然后明天卖出
# 123. Best Time to Buy and Sell Stock III
注意初始化，并且最后可能只买入一次
# 124. Binary Tree Maximum Path Sum
返回时只能返回某一侧的路径，若一侧为负，则让其为`0`表示不要一侧
# 125. Valid Palindrome
双指针，注意判断数字和字符的方法

也可以把数字字符选出来然后逆转比较是否`equals`
# 126. Word Ladder II
按层次遍历，每一层遍历的时候记录父节点

注意要一层遍历完后才能更新`visit`和加入`queue`
# 127. Word Ladder
可以使用双向广度优先搜索优化，每次从较少元素的那端搜，提升性能
# 128. Longest Consecutive Sequence
所有元素加到`set`中，对每个元素求一个上下界，求的过程中就删掉在一个序列中的元素

或者对每一个不存在比他还小`1`的数就长度，比如`4,3`都在集合里，遍历到4的时候发现`4-1=3`已经在了，就跳过，到`3`的时候再求
# 129. Sum Root to Leaf Numbers
先序遍历记录每个路径的值，每遍历一层就乘以`10`
# 130. Surrounded Regions
遍历每个`O`点，找到连通区域，标记为一个值，并记录是否需要覆盖（存在边界的`O`点）

更好的方法是对边界的`O`点找到连通区域，标记为不会改变，其余的都比较为改变
# 131. Palindrome Partitioning
递归，若前面的子串是回文，加入`result`，继续后面的
# 132 Palindrome Partitioning II
1.用记忆化的递归仍然搜索次数超时

2.考虑从某个点出发能左右延申的最大距离，分奇偶讨论，右边的点等于左边的点`+1`

3.考虑对某个位置到某个位置如果是回文，则此点等于左边的点`+1`，

> 某两个位置是否是回问可以先求出来，可以用延申的方法求会快一点，这种情况加上`3`的处理思路和`2`是差不多的
# 133. Clone Graph
用`map`记录是否已经创建过，注意`put`的时候要`put`新元素
# 134. Gas Station
从第一个`gas[i]`大于`cost[i]`的点出发，若从`i`到`j`，差的累积为负，说明`i`不是出发的点，此时直接从`j+1`开始（`i->j`中的所有点都不行）

若最终`gas`大于`cost`说明能走完，若小于说明没有这种点
# 135. Candy
先给第一个人`1`个糖
* 后面的人如果大于前一个人就`+1`，
* 若小于
  * 就取`1`（当前一个人很大）
  * 或取0（前一人为`1`），此时候重新赋值为`1`，再更新之前的值，若等于后面的了就`+1`

还可以正反两面考虑，先有前往后

两个数组
``` java
for (int i = 1; i < ratings.length; i++) {
    if (ratings[i] > ratings[i - 1]) {
        left2right[i] = left2right[i - 1] + 1;
    }
}
for (int i = ratings.length - 2; i >= 0; i--) {
    if (ratings[i] > ratings[i + 1]) {
        right2left[i] = right2left[i + 1] + 1;
    }
}
for (int i = 0; i < ratings.length; i++) {
    sum += Math.max(left2right[i], right2left[i]);
}
```
一个数组
``` java
for (int i = 1; i < ratings.length; i++) {
    if (ratings[i] > ratings[i - 1]) {
        candies[i] = candies[i - 1] + 1;
    }
}
int sum = candies[ratings.length - 1];
for (int i = ratings.length - 2; i >= 0; i--) {
    if (ratings[i] > ratings[i + 1]) {
        candies[i] = Math.max(candies[i], candies[i + 1] + 1);
    }
    sum += candies[i];
}
```