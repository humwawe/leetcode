# 1502. Can Make Arithmetic Progression From Sequence
排序后比较方差
# 1503. Last Moment Before All Ants Fall Out of a Plank
蚂蚁的碰撞可以看成蚂蚁的穿透
# 1504. Count Submatrices With All Ones
遍历两个不同的行，对这两行之间进行统计，将两行之间的和压缩成一个数，看是否等于两行的距离，然后统计这种距离出现过多少次

考虑到点`i,j`能形成的矩形，考虑其的宽度，每次向上找最小的宽度
``` java
for (int i = 0; i < row; i++) {
    for (int j = 0; j < col; j++) {
        if (mat[i][j] == 1) {
            dp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;
            int width = dp[i][j];
            for (int k = i; k >= 0; k--) {
                width = Math.min(width, dp[k][j]);
                result += width;
            }
        }
    }
}
```
找宽度和找高度都是一样，并且可以使用单调栈优化
- 每次遍历到`i,j`时，找到左侧高度比当前小的第一个位置
- 此时以`i,j`为右下角的子矩形数量可以分成两部分：

  第二部分：
  矩形的数量由
  下标`p`所指的柱子所能形成的矩形数量
  决定─┐
       │
       │          ┌第一部分：h[i][j] * (j - p)
      ┌┴─┐        │
      │  │        │ 
      │  │        │  
      │  │    ┌──┐│   
      │  │ ┌──┼──┼┴─┐
      │ ┌┴─┤..│..│..│
     ┌┴─┤xx│..│..│..│
     │xx│xx│..│..│..│
   ──┴──┴──┴──┴──┴──┴──
          │        │
          p        j  
``` java
for (int i = 1; i <= row; ++i) {
    stack.clear();
    stack.push(0);
    for (int j = 1; j <= col; ++j) {
        h[i][j] = mat[i - 1][j - 1] == 1 ? 1 + h[i - 1][j] : 0;
        while (!stack.isEmpty() && h[i][stack.peek()] > h[i][j]) {
            stack.pop();
        }
        dp[j] = h[i][j] * (j - stack.peek()) + dp[stack.peek()];
        stack.push(j);
        res += dp[j];
    }
}
```
# 1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits
贪心的取最小的放过来，利用树状数组记录移动位置，每次选取的时候考虑这个移动情况
# 1507. Reformat Date
直接处理
# 1508. Range Sum of Sorted Subarray Sums
前缀和，排序后累加
# 1509. Minimum Difference Between Largest and Smallest Value in Three Moves
排序后，去掉前面和后面的再比较最小值
# 1510. Stone Game IV
记忆化递归，考虑选不同是否对方能输
# 1512. Number of Good Pairs
暴力比较

考虑桶的思想
``` java
int result = 0;
for (int num : nums) {
    result += cnt[num];
    cnt[num]++;
}
return result;
```
# 1513. Number of Substrings With Only 1s
不断累加`1`的个数
# 1514. Path with Maximum Probability
可以看成最短路问题，注意到使用记忆化的`dfs`可能会错[参考](https://codeforces.com/blog/entry/16579?f0a28=1)
# 1515. Best Position for a Service Centre
三分套三分，二次曲线类可以三分，枚举两个左右`x`，考虑合适的`y`，看此时哪边更好

可以考虑求导的方法不断逼近最优值

可以模拟退火，朝四个方向移动
``` java
double eps = 1e-8;
double ret = 1e18;
double step = 100;
double t = 0.98;
while (step > eps) {
  int flag = 1;
  while (flag == 1) {
    flag = 0;
    for (int i = 0; i < 4; i++) {
      double nx = x + dx[i][0] * step;
      double ny = y + dx[i][1] * step;
      double tmp = dist(nx, ny);
      if (tmp < ret) {
        ret = tmp;
        x = nx;
        y = ny;
        flag = 1;
      }
    }
  }
  step *= t;
}
```
# 1518. Water Bottles
模拟
# 1519. Number of Nodes in the Sub-Tree With the Same Label
建树，然后`dfs`记录子节点对父节点的贡献
# 1520. Maximum Number of Non-Overlapping Substrings
记录要选每个字符时的最左和最右区间，然后拓展区间，最后按结束时间排序贪心的选择
# 1521. Find a Value of a Mysterious Function Closest to Target
有递减的性质，滑动窗口，记录某个位置`0`的个数
