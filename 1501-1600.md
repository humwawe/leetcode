# 1502. Can Make Arithmetic Progression From Sequence
排序后比较方差
# 1503. Last Moment Before All Ants Fall Out of a Plank
蚂蚁的碰撞可以看成蚂蚁的穿透
# 1504. Count Submatrices With All Ones
遍历两个不同的行，对这两行之间进行统计，将两行之间的和压缩成一个数，看是否等于两行的距离，然后统计这种距离出现过多少次

考虑到点`i,j`能形成的矩形，考虑其的宽度，每次向上找最小的宽度
``` java
for (int i = 0; i < row; i++) {
    for (int j = 0; j < col; j++) {
        if (mat[i][j] == 1) {
            dp[i][j] = j == 0 ? 1 : dp[i][j - 1] + 1;
            int width = dp[i][j];
            for (int k = i; k >= 0; k--) {
                width = Math.min(width, dp[k][j]);
                result += width;
            }
        }
    }
}
```
找宽度和找高度都是一样，并且可以使用单调栈优化
- 每次遍历到`i,j`时，找到左侧高度比当前小的第一个位置
- 此时以`i,j`为右下角的子矩形数量可以分成两部分：

  第二部分：
  矩形的数量由
  下标`p`所指的柱子所能形成的矩形数量
  决定─┐
       │
       │          ┌第一部分：h[i][j] * (j - p)
      ┌┴─┐        │
      │  │        │ 
      │  │        │  
      │  │    ┌──┐│   
      │  │ ┌──┼──┼┴─┐
      │ ┌┴─┤..│..│..│
     ┌┴─┤xx│..│..│..│
     │xx│xx│..│..│..│
   ──┴──┴──┴──┴──┴──┴──
          │        │
          p        j  
``` java
for (int i = 1; i <= row; ++i) {
    stack.clear();
    stack.push(0);
    for (int j = 1; j <= col; ++j) {
        h[i][j] = mat[i - 1][j - 1] == 1 ? 1 + h[i - 1][j] : 0;
        while (!stack.isEmpty() && h[i][stack.peek()] > h[i][j]) {
            stack.pop();
        }
        dp[j] = h[i][j] * (j - stack.peek()) + dp[stack.peek()];
        stack.push(j);
        res += dp[j];
    }
}
```