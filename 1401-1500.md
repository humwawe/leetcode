# 1401. Circle and Rectangle Overlapping
以长方形中心为坐标轴中心，求与右上角的向量和到圆心的向量，向量相减后的长度与半径比较
# 1402. Reducing Dishes
记忆化递归，考虑每道菜做和不做的最大值

贪心的思路，考虑最大的能否加入，可以的话看下一个元素是否可以正贡献
``` java
for (int i = satisfaction.length; i >= 0; i--) {
    sum += satisfaction[i];
    if (sum < 0) break;
    ans += sum;
}
```
# 1403. Minimum Subsequence in Non-Increasing Order
从最大的开始加
# 1404. Number of Steps to Reduce a Number in Binary Representation to One
转换成大数`bigInteger`进行操作
# 1405. Longest Happy String
看第一个和第二个的大小，如果一样大就一样选一个，否则考虑第一个选两个，第二个选一个
# 1406. Stone Game III
考虑`diff`，第一个人可以比第二个人多拿多少
# 1408. String Matching in an Array
暴力判断
# 1409. Queries on a Permutation With Key
模拟
# 1410. HTML Entity Parser
`replaceAll`把`&`的替换换到最后
# 1411. Number of Ways to Paint N × 3 Grid
类似状压`dp`，只不过有三个值，先将可以的排列求出来并用`list`的下标记录，再考虑每个状态可以如何转移过来

或者遍历`3`个位置,每个位置遍历`3`次

找规律的方式，第一层可以摆出`6`个`ABA`类型的和`6`个`ABC`类型，对于下一层，`ABA`可以拼接`2`个`ABC`和`3`个`ABA`，`ABC`可以拼接`2`个`ABC`和`2`个`ABA`
``` java
dp[0] = 6;
dp[1] = 6;
for (int index = 1; index < n; index++) {
    temp = new long[2];
    temp[0] = (dp[0] * 3 + dp[1] * 2) % mod;
    temp[1] = (dp[0] * 2 + dp[1] * 2) % mod;
    dp = temp;
}
```
# 1413. Minimum Value to Get Positive Step by Step Sum
记录前缀和的最小值，用`1`减去该值
# 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K
求出`fibonacci`数，放入数组中，从大到小选取
> `fibonacci`求到`45`即可满足`1e9`
# 1415. The k-th Lexicographical String of All Happy Strings of Length n
递归遍历`abc`，记录`prev`
# 1416. Restore The Array
记忆化递归，考虑前多少个字符组成的和小于`k`，加上后面的
# 1417. Reformat The String
将数字和字符记下来，根据数量构造
# 1418. Display Table of Food Orders in a Restaurant
模拟记录
# 1419. Minimum Number of Frogs Croaking
记录每个字母的出现次数，如果出现某个后面的大于前面的则不合法，如果最后一个字符有`1`，则全部减`1`，`result`记录最开头字符的最大出现次数
# 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons
记忆化递归，遍历数组，记录最大值
# 1422. Maximum Score After Splitting a String
遍历统计
# 1423. Maximum Points You Can Obtain from Cards
前缀和，`k`可以分为前后部分，也可以维护`len-k`的窗口
# 1424. Diagonal Traverse II
对角线`i+j`值一样，按`i+j`组合
# 1425. Constrained Subsequence Sum
`dp`的单调队列优化，队列记录窗口中`dp`的最大值下标
# 1431. Kids With the Greatest Number of Candies
求最大值后，对每个元素比较
# 1432. Max Difference You Can Get From Changing an Integer
大的用`9`替换，小的用`1`或者`0`替换，可以暴力的直接替换比较
# 1433. Check If a String Can Break Another String
从大到小依次比较，因此可以排序后比较

考虑计数，一加一减累和
``` java
for (int i = 0; i < s1.length(); ++i) {
    --cnt[s1[i] - 'a'];
    ++cnt[s2[i] - 'a'];
}

int sum = 0;
boolean big1 = true, big2 = true;
for (int i = 25; i >= 0; --i) {
    sum += cnt[i];
    if (big1 && sum > 0) big1 = false;
    if (big2 && sum < 0) big2 = false;
    if (!big1 && !big2) return false;
}
return true;
```
# 1434. Number of Ways to Wear Different Hats to Each Other
直接对每个人分配会超时，主要到帽子多人少，因此考虑对每个帽子给人分配，建立帽子跟人的关系，考虑每个帽子是否分给某个人，对人进行状态压缩
# 1436. Destination City
把起点和终点做成两个集合，终点集减去起点集，剩下的一个元素就是结果
# 1437. Check If All 1's Are at Least Length K Places Away
顺序遍历，每次遇到`1`的时候`check`，设置最开始的位置很小可以避免边界情况
# 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit
`treemap`维护窗口的最大值和最小值

也可以用两个单调队列分别维护最大值和最小值
``` java
int start=0;
for (int end=0; end<nums.length;end++){
    while(!maxQ.isEmpty() && nums[maxQ.peekLast()]<nums[end]){
        maxQ.pollLast();
    }
    maxQ.add(end);
    
    while(!minQ.isEmpty() && nums[minQ.peekLast()]>nums[end]){
        minQ.pollLast();
    }
    minQ.add(end);
    
    while(!maxQ.isEmpty() && !minQ.isEmpty() && nums[maxQ.peek()]-nums[minQ.peek()]>limit){
        if(maxQ.peek()<=start) maxQ.poll();
        if(minQ.peek()<=start) minQ.poll();
        start++;
    }
    ans = Math.max(ans,end-start+1);
}
```
# 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows
先保存第一行的数，然后把第二行的拿出来结合相加，排序选前`k`个，再重复

考虑二分答案，找小于答案的数有多少个
