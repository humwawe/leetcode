# 1401. Circle and Rectangle Overlapping
以长方形中心为坐标轴中心，求与右上角的向量和到圆心的向量，向量相减后的长度与半径比较
# 1402. Reducing Dishes
记忆化递归，考虑每道菜做和不做的最大值

贪心的思路，考虑最大的能否加入，可以的话看下一个元素是否可以正贡献
``` java
for (int i = satisfaction.length; i >= 0; i--) {
    sum += satisfaction[i];
    if (sum < 0) break;
    ans += sum;
}
```
# 1403. Minimum Subsequence in Non-Increasing Order
从最大的开始加
# 1404. Number of Steps to Reduce a Number in Binary Representation to One
转换成大数`bigInteger`进行操作
# 1405. Longest Happy String
看第一个和第二个的大小，如果一样大就一样选一个，否则考虑第一个选两个，第二个选一个
# 1406. Stone Game III
考虑`diff`，第一个人可以比第二个人多拿多少
# 1408. String Matching in an Array
暴力判断
# 1409. Queries on a Permutation With Key
模拟
# 1410. HTML Entity Parser
`replaceAll`把`&`的替换换到最后
# 1411. Number of Ways to Paint N × 3 Grid
类似状压`dp`，只不过有三个值，先将可以的排列求出来并用`list`的下标记录，再考虑每个状态可以如何转移过来

或者遍历`3`个位置,每个位置遍历`3`次

找规律的方式，第一层可以摆出`6`个`ABA`类型的和`6`个`ABC`类型，对于下一层，`ABA`可以拼接`2`个`ABC`和`3`个`ABA`，`ABC`可以拼接`2`个`ABC`和`2`个`ABA`
``` java
dp[0] = 6;
dp[1] = 6;
for (int index = 1; index < n; index++) {
    temp = new long[2];
    temp[0] = (dp[0] * 3 + dp[1] * 2) % mod;
    temp[1] = (dp[0] * 2 + dp[1] * 2) % mod;
    dp = temp;
}
```
# 1413. Minimum Value to Get Positive Step by Step Sum
记录前缀和的最小值，用`1`减去该值
# 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K
求出`fibonacci`数，放入数组中，从大到小选取
> `fibonacci`求到`45`即可满足`1e9`
# 1415. The k-th Lexicographical String of All Happy Strings of Length n
递归遍历`abc`，记录`prev`
# 1416. Restore The Array
记忆化递归，考虑前多少个字符组成的和小于`k`，加上后面的
# 1417. Reformat The String
将数字和字符记下来，根据数量构造
# 1418. Display Table of Food Orders in a Restaurant
模拟记录
# 1419. Minimum Number of Frogs Croaking
记录每个字母的出现次数，如果出现某个后面的大于前面的则不合法，如果最后一个字符有`1`，则全部减`1`，`result`记录最开头字符的最大出现次数
# 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons
记忆化递归，遍历数组，记录最大值
