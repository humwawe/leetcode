# 501. Find Mode in Binary Search Tree
中序遍历，记录前一个节点
>这里是记录前一个节点，而不是父节点，用全局变量记录赋值
# 502. IPO
贪心的方法找到比`w`大的中最大收益的，直接用两个堆，将所有小于`w`的全放到另一个堆中，弹出一个最大收益
# 503. Next Greater Element II
单调栈，在弹出的时候赋值，遍历到`2*len`，栈只需维护前半部分
# 504. Base 7
调用库函数

也可以用短除法的思路，注意要考虑正负号
``` java
while(num != 0){
    sb.append(num % 7);
    num = num / 7;
}
```
# 506. Relative Ranks
把数据和编号放到堆中，依次弹出
# 507. Perfect Number
开平方遍历所有因子，加起来看是否相等
# 508. Most Frequent Subtree Sum
后序遍历将所有值的频率记录下来，最后返回最大值的元素
# 509. Fibonacci Number
用两个值递推即可
# 513. Find Bottom Left Tree Value
层序遍历保留第一个值

也可以`dfs`，在更新`depth`的时候更新结果
# 514. Freedom Trail
记忆化的递归，考虑左边走和右边走的情况
# 515. Find Largest Value in Each Tree Row
层次遍历，记录最大值
# 516. Longest Palindromic Subsequence
记忆化的递归，考虑去掉左边一个、右边一个的情况，当两边想等时，考虑去掉两个的情况