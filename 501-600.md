# 501. Find Mode in Binary Search Tree
中序遍历，记录前一个节点
>这里是记录前一个节点，而不是父节点，用全局变量记录赋值
# 502. IPO
贪心的方法找到比`w`大的中最大收益的，直接用两个堆，将所有小于`w`的全放到另一个堆中，弹出一个最大收益
# 503. Next Greater Element II
单调栈，在弹出的时候赋值，遍历到`2*len`，栈只需维护前半部分
# 504. Base 7
调用库函数

也可以用短除法的思路，注意要考虑正负号
``` java
while(num != 0){
    sb.append(num % 7);
    num = num / 7;
}
```
# 506. Relative Ranks
把数据和编号放到堆中，依次弹出
# 507. Perfect Number
开平方遍历所有因子，加起来看是否相等
# 508. Most Frequent Subtree Sum
后序遍历将所有值的频率记录下来，最后返回最大值的元素
# 509. Fibonacci Number
用两个值递推即可
# 513. Find Bottom Left Tree Value
层序遍历保留第一个值

也可以`dfs`，在更新`depth`的时候更新结果
# 514. Freedom Trail
记忆化的递归，考虑左边走和右边走的情况
# 515. Find Largest Value in Each Tree Row
层次遍历，记录最大值
# 516. Longest Palindromic Subsequence
记忆化的递归，考虑去掉左边一个、右边一个的情况，当两边想等时，考虑去掉两个的情况
# 517. Super Washing Machines
考虑四个洗衣机，`[0, 0, 11, 5]`，最终为`[4, 4, 4, 4]`

做差，得到`[-4, -4, 7, 1]`，负数表示还需要的衣服数，正数表示多余的衣服数。目的是将数组每一项变为`0`

对于第一个洗衣机来说，需要四件衣服可以从第二个洗衣机获得，把`-4`移给二号洗衣机，变为`[0, -8, 7, 1]`

此时二号洗衣机需要八件衣服，那么至少需要移动8次。那么差值数组变为`[0, 0, -1, 1]`

此时三号洗衣机还缺1件，就从四号洗衣机处获得，此时差值数组成功变为了`[0, 0, 0, 0]`
>移动是可以同时进行的，移动的最大次数就是差值数组中出现的绝对值最大的数字，`8`次
# 518. Coin Change 2
完全背包问题，对`coins`的循环在外面，选完了就不再选了
# 519. Random Flip Matrix
记录出现的点即可，出现的点可以转换成一维数组的方式，空间会小点

另外可以考虑把用到的点跟最后的点交换，当再次随到该值就去拿交换的值，`random`调用最少
``` java
public int[] flip() {
    int result = (int)(Math.random() * size--);

    while (map.containsKey(result)) {
        result = map.get(result);
    }

    map.put(result, size);

    int x = result % n_rows;
    int y = result / n_rows;

    return new int[]{x, y};
}
```
# 520. Detect Capital
直接判断
1. 全大写
2. 全小写
3. 仅首字母大写

也可以统计大小写个数，再判断
# 521. Longest Uncommon Subsequence I 
返回最长的即可，相等返回`-1`
# 522. Longest Uncommon Subsequence II
按长度排序，从前往后，考虑所有大于等于该长度的元素是否有包含的，有就考虑下一个，没有即可返回
> 长度肯定是某个串的长度（如果是其中的子串，那更长的肯定也可以）
# 523. Continuous Subarray Sum
前缀和暴力求解，要注意`k=0`的情况

更好的方法是用`map`记录当前的和与下标，对`(sum[j]−sum[i])%k`是否等于`0`等价于`sum[j]%k=sum[i]%k`
``` java
map.put(0, -1);
for (int i = 0; i < nums.length; i++) {
  sum += nums[i];
  if (k != 0)
      sum = sum % k;
  if (map.containsKey(sum)) {
      if (i - map.get(sum) > 1)
          return true;
  } else
      map.put(sum, i);
}

```
也可以用`set`，不过因为数组长度要大于`2`，在往`set`里加的时候要缓存一下
``` java
for (int i = 0; i < len; i++) {
    sum[i+1] = sum[i] + nums[i];
    int res = k == 0 ? sum[i+1] : sum[i+1] % k;
    if (set.contains(res)) return true;
    set.add(cache);
    cache = res;
}
```
# 524. Longest Word in Dictionary through Deleting
排序后找到第一个满足条件的

也可以不排序，遍历找比当前更好的
# 525. Contiguous Array
把`0`看成`-1`，原题即变为某个子数组加起来为和`0`
>将前缀和记下来，考虑后面是否遇到相同的和
# 526. Beautiful Arrangement
递归，考虑每个位置能放置的点
# 528. Random Pick with Weight
记录前缀和的位置，`treemap`来存，考虑`random`出来的在哪一个下标

也可以构造前缀和数组，二分查找
# 529. Minesweeper
递归求解
1. 点击地雷--显示`X`，返回
2. 点空方块--若周围有地雷，显示数字`n`，返回
3. 点空方块--若周围没有地雷，显示空白`B`，并递归显示相连的方块
# 530. Minimum Absolute Difference in BST
中序遍历记录前一个节点
# 532. K-diff Pairs in an Array
用另外一个`set`记录已经出现的最小值，避免重复，可以不排序，考虑不同的大小关系
535. Encode and Decode TinyURL
直接用数字编号，`map`记录，然后返回

可以产生某个随机值，用`map`记录，产生时如果出现了该随机值，再`random`一遍
# 537. Complex Number Multiplication
按`+`和`i`切分，直接计算