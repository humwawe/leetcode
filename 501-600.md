# 501. Find Mode in Binary Search Tree
中序遍历，记录前一个节点
>这里是记录前一个节点，而不是父节点，用全局变量记录赋值
# 502. IPO
贪心的方法找到比`w`大的中最大收益的，直接用两个堆，将所有小于`w`的全放到另一个堆中，弹出一个最大收益
# 503. Next Greater Element II
单调栈，在弹出的时候赋值，遍历到`2*len`，栈只需维护前半部分
# 504. Base 7
调用库函数

也可以用短除法的思路，注意要考虑正负号
``` java
while(num != 0){
    sb.append(num % 7);
    num = num / 7;
}
```
# 506. Relative Ranks
把数据和编号放到堆中，依次弹出
# 507. Perfect Number
开平方遍历所有因子，加起来看是否相等
# 508. Most Frequent Subtree Sum
后序遍历将所有值的频率记录下来，最后返回最大值的元素
# 509. Fibonacci Number
用两个值递推即可
# 513. Find Bottom Left Tree Value
层序遍历保留第一个值

也可以`dfs`，在更新`depth`的时候更新结果
# 514. Freedom Trail
记忆化的递归，考虑左边走和右边走的情况
# 515. Find Largest Value in Each Tree Row
层次遍历，记录最大值
# 516. Longest Palindromic Subsequence
记忆化的递归，考虑去掉左边一个、右边一个的情况，当两边想等时，考虑去掉两个的情况
# 517. Super Washing Machines
考虑四个洗衣机，`[0, 0, 11, 5]`，最终为`[4, 4, 4, 4]`

做差，得到`[-4, -4, 7, 1]`，负数表示还需要的衣服数，正数表示多余的衣服数。目的是将数组每一项变为`0`

对于第一个洗衣机来说，需要四件衣服可以从第二个洗衣机获得，把`-4`移给二号洗衣机，变为`[0, -8, 7, 1]`

此时二号洗衣机需要八件衣服，那么至少需要移动8次。那么差值数组变为`[0, 0, -1, 1]`

此时三号洗衣机还缺1件，就从四号洗衣机处获得，此时差值数组成功变为了`[0, 0, 0, 0]`
>移动是可以同时进行的，移动的最大次数就是差值数组中出现的绝对值最大的数字，`8`次
# 518. Coin Change 2
完全背包问题，对`coins`的循环在外面，选完了就不再选了
# 519. Random Flip Matrix
记录出现的点即可，出现的点可以转换成一维数组的方式，空间会小点

另外可以考虑把用到的点跟最后的点交换，当再次随到该值就去拿交换的值，`random`调用最少
``` java
public int[] flip() {
    int result = (int)(Math.random() * size--);

    while (map.containsKey(result)) {
        result = map.get(result);
    }

    map.put(result, size);

    int x = result % n_rows;
    int y = result / n_rows;

    return new int[]{x, y};
}
```
# 520. Detect Capital
直接判断
1. 全大写
2. 全小写
3. 仅首字母大写

也可以统计大小写个数，再判断
# 521. Longest Uncommon Subsequence I 
返回最长的即可，相等返回`-1`
# 522. Longest Uncommon Subsequence II
按长度排序，从前往后，考虑所有大于等于该长度的元素是否有包含的，有就考虑下一个，没有即可返回
> 长度肯定是某个串的长度（如果是其中的子串，那更长的肯定也可以）
# 523. Continuous Subarray Sum
前缀和暴力求解，要注意`k=0`的情况

更好的方法是用`map`记录当前的和与下标，对`(sum[j]−sum[i])%k`是否等于`0`等价于`sum[j]%k=sum[i]%k`
``` java
map.put(0, -1);
for (int i = 0; i < nums.length; i++) {
  sum += nums[i];
  if (k != 0)
      sum = sum % k;
  if (map.containsKey(sum)) {
      if (i - map.get(sum) > 1)
          return true;
  } else
      map.put(sum, i);
}

```
也可以用`set`，不过因为数组长度要大于`2`，在往`set`里加的时候要缓存一下
``` java
for (int i = 0; i < len; i++) {
    sum[i+1] = sum[i] + nums[i];
    int res = k == 0 ? sum[i+1] : sum[i+1] % k;
    if (set.contains(res)) return true;
    set.add(cache);
    cache = res;
}
```
# 524. Longest Word in Dictionary through Deleting
排序后找到第一个满足条件的

也可以不排序，遍历找比当前更好的
# 525. Contiguous Array
把`0`看成`-1`，原题即变为某个子数组加起来为和`0`
>将前缀和记下来，考虑后面是否遇到相同的和
# 526. Beautiful Arrangement
递归，考虑每个位置能放置的点
# 528. Random Pick with Weight
记录前缀和的位置，`treemap`来存，考虑`random`出来的在哪一个下标

也可以构造前缀和数组，二分查找
# 529. Minesweeper
递归求解
1. 点击地雷--显示`X`，返回
2. 点空方块--若周围有地雷，显示数字`n`，返回
3. 点空方块--若周围没有地雷，显示空白`B`，并递归显示相连的方块
# 530. Minimum Absolute Difference in BST
中序遍历记录前一个节点
# 532. K-diff Pairs in an Array
用另外一个`set`记录已经出现的最小值，避免重复，可以不排序，考虑不同的大小关系
535. Encode and Decode TinyURL
直接用数字编号，`map`记录，然后返回

可以产生某个随机值，用`map`记录，产生时如果出现了该随机值，再`random`一遍
# 537. Complex Number Multiplication
按`+`和`i`切分，直接计算
# 538. Convert BST to Greater Tree
反中序遍历，记录之前的和即可
# 539. Minimum Time Difference
排序后计算差值

也可以转换成分钟数计算
# 540. Single Element in a Sorted Array
根据`mid`所处位置奇偶，和后一个元素是否相等，判断处于前半部分还是后半分二分求解
# 541. Reverse String II
每k个逆转即可

另外考虑直接按下标翻转
``` java
for (int start = 0; start < a.length; start += 2 * k) {
    int i = start, j = Math.min(start + k - 1, a.length - 1);
    while (i < j) {
        char tmp = a[i];
        a[i++] = a[j];
        a[j--] = tmp;
    }
}
return new String(a);
```
# 542. 01 Matrix
`bfs`，将`0`全部加入队列，一圈一圈遍历

也可以动态规划，考虑斜上和斜下
``` java
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        if (matrix[i][j] == 0)
            dist[i][j] = 0;
        else {
            if (i > 0)
                dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);
            if (j > 0)
                dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);
        }
    }
}
for (int i = rows - 1; i >= 0; i--) {
    for (int j = cols - 1; j >= 0; j--) {
        if (i < rows - 1)
            dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);
        if (j < cols - 1)
            dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);
    }
}
```
# 543. Diameter of Binary Tree
直径其实是每个节点的左右子树的高度和的最大值，因此记录遍历过程中最大值，返回左右子树的最大高度
# 546. Remove Boxes
暴力的方法考虑所有情况超时，加入记忆化仍然超时

考虑更好的遍历方法，对`ABACDA`，考虑去掉`CD`后的`ABAA`，去掉`B`后的`AAA`
>准备三维`dp`，`dp[l][r]][k]`表示`l`到`r`，后面有`k`个元素跟`r`位置元素一样
``` java
dp[l][r][k] = dp[l][r−1][0]+(k+1)∗(k+1) // 去掉 r到最后的k+1个
dp[l][r][k] = max(dp[l][r][k], dp[l][i][k+1] + dp[i+1][r-1][0]) // 去掉中间一段，如ABACDA->ABAA
```
# 547. Friend Circles
并查集和搜索都可以解决，并查集在合并的时候可以直接对答案减`1`，然后返回
# 551. Student Attendance Record I
统计`A`的个数是否超过`2`，以及是否存在`LLL`即可
# 552. Student Attendance Record II
`dp[i][j][k]`，`i`表示第`i`个位置，`j`表示非`L`、`L`、`LL`结尾，`k`表示`A`的个数

`dp[i][0][1]`非`L`结尾且`A`出现了一个，可以`dp[i-1][0][1]`（此时以`P`结尾）和`dp[i-1][0][0]`（此时以A结尾）...

