# 501. Find Mode in Binary Search Tree
中序遍历，记录前一个节点
>这里是记录前一个节点，而不是父节点，用全局变量记录赋值
# 502. IPO
贪心的方法找到比`w`大的中最大收益的，直接用两个堆，将所有小于`w`的全放到另一个堆中，弹出一个最大收益
# 503. Next Greater Element II
单调栈，在弹出的时候赋值，遍历到`2*len`，栈只需维护前半部分
# 504. Base 7
调用库函数

也可以用短除法的思路，注意要考虑正负号
``` java
while(num != 0){
    sb.append(num % 7);
    num = num / 7;
}
```
# 506. Relative Ranks
把数据和编号放到堆中，依次弹出
# 507. Perfect Number
开平方遍历所有因子，加起来看是否相等
# 508. Most Frequent Subtree Sum
后序遍历将所有值的频率记录下来，最后返回最大值的元素
# 509. Fibonacci Number
用两个值递推即可
# 513. Find Bottom Left Tree Value
层序遍历保留第一个值

也可以`dfs`，在更新`depth`的时候更新结果
# 514. Freedom Trail
记忆化的递归，考虑左边走和右边走的情况
# 515. Find Largest Value in Each Tree Row
层次遍历，记录最大值
# 516. Longest Palindromic Subsequence
记忆化的递归，考虑去掉左边一个、右边一个的情况，当两边想等时，考虑去掉两个的情况
# 517. Super Washing Machines
考虑四个洗衣机，`[0, 0, 11, 5]`，最终为`[4, 4, 4, 4]`

做差，得到`[-4, -4, 7, 1]`，负数表示还需要的衣服数，正数表示多余的衣服数。目的是将数组每一项变为`0`

对于第一个洗衣机来说，需要四件衣服可以从第二个洗衣机获得，把`-4`移给二号洗衣机，变为`[0, -8, 7, 1]`

此时二号洗衣机需要八件衣服，那么至少需要移动8次。那么差值数组变为`[0, 0, -1, 1]`

此时三号洗衣机还缺1件，就从四号洗衣机处获得，此时差值数组成功变为了`[0, 0, 0, 0]`
>移动是可以同时进行的，移动的最大次数就是差值数组中出现的绝对值最大的数字，`8`次
# 518. Coin Change 2
完全背包问题，对`coins`的循环在外面，选完了就不再选了
# 519. Random Flip Matrix
记录出现的点即可，出现的点可以转换成一维数组的方式，空间会小点

另外可以考虑把用到的点跟最后的点交换，当再次随到该值就去拿交换的值，`random`调用最少
``` java
public int[] flip() {
    int result = (int)(Math.random() * size--);

    while (map.containsKey(result)) {
        result = map.get(result);
    }

    map.put(result, size);

    int x = result % n_rows;
    int y = result / n_rows;

    return new int[]{x, y};
}
```