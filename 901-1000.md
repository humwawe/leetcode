# 901. Online Stock Span
单调栈，存当前的价格和前面的连续个数，每次入栈考虑与栈顶的关系
# 902. Numbers At Most N Given Digit Set
* 当长度小于`n`的长度，则可以随便取
* 长度相等时，第一位小于`n`的第一位，则后面随便取，等于的时候递归处理

可以套用数位`dp`模板
# 903. Valid Permutations for DI Sequence
`dp[i][j]`表示`i`位置放`j`的个数，只需考虑前一位的情况
* D: dp[i][j] = dp[i-1][j,j+1,j+2,...,i-1]
* I: dp[i][j] = dp[i-1][0,1,2,...,j-1]

第`i`为放置与前面重复的时候，将前面的所有大于`i`的都加`1`变化

如`DI`现在是`1 0 2`，当再接一个`D`
* 如果放`2`，则将`1 0 2`变为`1 0 3`
* 如果放`1`，则将`1 0 2`变为`2 0 3`
* 如果放`0`，则将`1 0 2`变为`2 1 3`
# 904. Fruit Into Baskets
滑动窗口，窗口内最多两个元素
# 905. Sort Array By Parity
双指针，向中间靠拢，交换元素
# 906. Super Palindromes
从`1`开始，将该数字转为奇和偶回文，平方后判断是否在要求区间
> 1e18 -> 1e9f->1e5
# 907. Sum of Subarray Minimums
通过单调栈找某个位置左右能延伸的开区间
# 908. Smallest Range I
考虑最大值和最小值即可
# 909. Snakes and Ladders
`bfs`最短路
# 910. Smallest Range II
排序后遍历，前面的数加`k`，后面的数减`k`，考虑变化的这几个端点的情况
# 911. Online Election
记录每个时刻的候选者，然后查找
# 912. Sort an Array
直接排序
# 913. Cat and Mouse
`dfs`走每一步，平局的时候是`step`走到`2*len`的情况（正确性未知）

另外一种思路是从每种确定状态倒推染色，最后看初始位置的状态
# 914. X of a Kind in a Deck of Cards
求两两的最大公约数是否大于`2`
# 915. Partition Array into Disjoint Intervals
遍历求某个点左边最大值和右边最小值，再次遍历当最大值小于等于最小值即可
# 916. Word Subsets
统计`b`中每个单词出现的最大次数，看`a`是否满足
# 917. Reverse Only Letters
双指针交换
# 918. Maximum Sum Circular Subarray
用`Kadane`算法求数组中最大连续子数组
> 累加，碰到负数重新累计，记录遇到的最大值

由于环形，因此如果在环形中，第一个和最后一个肯定会被选中，因此再次使用`Kadane`算法选择出去这两个点的最小连续子数组，用和减去即是包含环形的最大值
# 919. Complete Binary Tree Inserter
用数组编号每个节点，并记录`size`，插入一个节点`size/2`即可找到父节点

也可以`bfs`将每个节点放到`list`里面，同样用索引查找

可以用队列记录那些子节点不全的节点，插入时队首进行插入，当两边都插满了，弹出，新的节点放入队列后面
# 920. Number of Music Playlists
`dp[i][j]`表示`i`首歌，`j`首不同的播放数
* 如果是新歌，则可以选剩余的歌
* 如果是之前重复的，因为最后的`k`首不相同，因此可以选前面的任意一首
