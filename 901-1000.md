# 901. Online Stock Span
单调栈，存当前的价格和前面的连续个数，每次入栈考虑与栈顶的关系
# 902. Numbers At Most N Given Digit Set
* 当长度小于`n`的长度，则可以随便取
* 长度相等时，第一位小于`n`的第一位，则后面随便取，等于的时候递归处理

可以套用数位`dp`模板
# 903. Valid Permutations for DI Sequence
`dp[i][j]`表示`i`位置放`j`的个数，只需考虑前一位的情况
* D: dp[i][j] = dp[i-1][j,j+1,j+2,...,i-1]
* I: dp[i][j] = dp[i-1][0,1,2,...,j-1]

第`i`为放置与前面重复的时候，将前面的所有大于`i`的都加`1`变化

如`DI`现在是`1 0 2`，当再接一个`D`
* 如果放`2`，则将`1 0 2`变为`1 0 3`
* 如果放`1`，则将`1 0 2`变为`2 0 3`
* 如果放`0`，则将`1 0 2`变为`2 1 3`
# 904. Fruit Into Baskets
滑动窗口，窗口内最多两个元素
# 905. Sort Array By Parity
双指针，向中间靠拢，交换元素
# 906. Super Palindromes
从`1`开始，将该数字转为奇和偶回文，平方后判断是否在要求区间
> 1e18 -> 1e9f->1e5
# 907. Sum of Subarray Minimums
通过单调栈找某个位置左右能延伸的开区间
# 908. Smallest Range I
考虑最大值和最小值即可
# 909. Snakes and Ladders
`bfs`最短路
# 910. Smallest Range II
排序后遍历，前面的数加`k`，后面的数减`k`，考虑变化的这几个端点的情况
# 911. Online Election
记录每个时刻的候选者，然后查找
# 912. Sort an Array
直接排序
# 913. Cat and Mouse
`dfs`走每一步，平局的时候是`step`走到`2*len`的情况（正确性未知）

另外一种思路是从每种确定状态倒推染色，最后看初始位置的状态
# 914. X of a Kind in a Deck of Cards
求两两的最大公约数是否大于`2`