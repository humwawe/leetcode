# 1001. Grid Illumination
四个方向：`x`、`y`、`x+y`、`x-y`记录出现的次数
# 1002. Find Common Characters
求每个字母在所有字符中的最小出现次数
# 1003. Check If Word Is Valid After Substitutions
遇到`c`进行一次结算，将`a`和`b`保留在栈中
> 第一个`c`前肯定是`ab`
# 1004. Max Consecutive Ones III
滑动窗口
# 1005. Maximize Sum Of Array After K Negations
排序每次对最小值进行取反操作
# 1006. Clumsy Factorial
四个一组讨论
# 1007. Minimum Domino Rotations For Equal Row
考虑上下全换成`1`到`6`的情况
>其实只可能是`a[0]`和`b[0]`中的一个数
# 1008. Construct Binary Search Tree from Preorder Traversal
分区间构造
# 1009. Complement of Base 10 Integer
构造全`1`异或
# 1010. Pairs of Songs With Total Durations Divisible by 60
求余的`two sum`
# 1011. Capacity To Ship Packages Within D Days
二分判断，求最小满足的
# 1012. Numbers With Repeated Digits
数位`dp`
# 1013. Partition Array Into Three Parts With Equal Sum
累加到`sum/3`，计数
# 1014. Best Sightseeing Pair
记录左边的`max`
# 1015. Smallest Integer Divisible by K
看某个余数是否已经出现，出现过说明要开始循环节了

除去`2`和`5`，其他都有解

另有等价的两个式子，后面的式子可以解决溢出问题
``` java
while (x % k != 0) {
    x = x * 10 + 1;
}
```
``` java
while (x % k != 0) {
    x = x % k;
    x = x * 10 + 1;
}
```
# 1016. Binary String With Substrings Representing 1 To N
`s`为`1000`位，将`s`以`1`开头的且长度小于`32`，值小于等于`n`的全放到`set`里，最后看`size`和`n`是否相等

另外考虑`s`的长度限制了表示的数，因此直接从`1`到`n`遍历，很快会有不能表示的数
# 1017. Convert to Base -2
考虑当前为时负还是正，把当前位置的影响加回去，如果为正则减`1`，为负加`1`
# 1018. Binary Prefix Divisible By 5
用余数进行后面的计算防止溢出
# 1019. Next Greater Node In Linked List
单调栈
# 1020. Number of Enclaves
每次`dfs`统计个数，并记录该联通块是否应该加入结果

也可以将最外圈的先加入，再从最外圈的进行`bfs`
# 1021. Remove Outermost Parentheses
`count`记录，将一头一尾去掉即可
# 1022. Sum of Root To Leaf Binary Numbers
递归路径，记录每个路径的值
# 1023. Camelcase Matching
依次比较
# 1024. Video Stitching
贪心每一轮找能更新的最大的值
# 1025. Divisor Game
当为偶数时，则一直拿`1`即可获胜，奇数拿一次变成偶数，对方获胜
# 1026. Maximum Difference Between Node and Ancestor
记录遍历到的最大值最小值，每次拿出来与当前节点比较
# 1027. Longest Arithmetic Sequence
`dp[i][diff]`，表示到`i`位置，`diff`差值的最大长度
``` java
dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] + 1)
```
# 1028. Recover a Tree From Preorder Traversal
先把每个点的深度记下来，然后每次找是否存在深度一样的点，分别放置左右节点
# 1029. Two City Scheduling
假设全部人都取`b`，现在选一半的人去`a`，最好选`cost[i][0]-cost[i][1]`最小的
# 1030. Matrix Cells in Distance Order
从初始点开始向外`bfs`
# 1031. Maximum Sum of Two Non-Overlapping Subarrays
前缀和，记录到某个位置长为`l`的最大值，从后遍历，记录`m`长度最大值
# 1032. Stream of Characters
从单词最后一个字符构建`trie`树
# 1033. Moving Stones Until Consecutive
最大值即是两边都往中间一步一步走，最小值需要考虑`0,1,2`三种情况
# 1034. Coloring A Border
`bfs`
# 1035. Uncrossed Lines
最长公共子序列
# 1036. Escape a Large Maze
`block`最多`200`，最多能围成的点是斜三角`n*(n-1)/2`个，因此考虑从起点或者终点是否都能遍历到这么多个点，可以则说明可以到达
# 1037. Valid Boomerang
判断斜率

三个点是否组成的三角形面积为`0`，面积公式为`S=1/2[(x1y2-x2y1)+(x2y3-x3y2)+(x3y1-x1y3)]`
``` java
(p[0][0] * (p[1][1] - p[2][1]) + p[1][0] * (p[2][1] - p[0][1]) + p[2][0] * (p[0][1] - p[1][1])) != 0;
```
# 1038. Binary Search Tree to Greater Sum Tree
逆着做中序遍历，遍历某个左边节点的时候，存储了大于等于该值的结果
# 1039. Minimum Score Triangulation of Polygon
区间`dp`问题，跟石子堆合并差不多

`dp[i][j]`合并后，只需再考虑i位置和j位置与其他点的关系
``` java
for (int len = 3; len <= N; len++) {
    for (int left = 0; left <= N - len; left++) {
        int right = left + len - 1;
        dp[left][right] = Integer.MAX_VALUE;
        for (int i = left + 1; i < right; i++) {
            dp[left][right] = Math.min(dp[left][right], dp[left][i] + dp[i][right] + A[i] * A[left] * A[right]);
        }
    }
}
return dp[0][N - 1];
```
# 1040. Moving Stones Until Consecutive II
滑动窗口，填充空位
# 1041. Robot Bounded In Circle
中间形成环，但是仍然可能能走出去，所以只需考虑起点和终点的关系，如果起点终点不相等，且方向一样，则没有环，方向不同则有环
# 1042. Flower Planting With No Adjacent
考虑每个点的临近点的颜色，选一个没有用过的着色
# 1043. Partition Array for Maximum Sum
`dp[i]`，表示到`i`位置的最大值
``` java
for (int j = i; i - j + 1 <= k && j > 0; j--) {
    max = Math.max(max, a[j - 1]);
    dp[i] = Math.max(dp[i], dp[j - 1] + (i - j + 1) * max);
}
```
# 1044. Longest Duplicate Substring
`hash`，二分长度
> 很容易冲突，考虑做两个`hash`