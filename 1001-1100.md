# 1001. Grid Illumination
四个方向：`x`、`y`、`x+y`、`x-y`记录出现的次数
# 1002. Find Common Characters
求每个字母在所有字符中的最小出现次数
# 1003. Check If Word Is Valid After Substitutions
遇到`c`进行一次结算，将`a`和`b`保留在栈中
> 第一个`c`前肯定是`ab`
# 1004. Max Consecutive Ones III
滑动窗口
# 1005. Maximize Sum Of Array After K Negations
排序每次对最小值进行取反操作
# 1006. Clumsy Factorial
四个一组讨论
# 1007. Minimum Domino Rotations For Equal Row
考虑上下全换成`1`到`6`的情况
>其实只可能是`a[0]`和`b[0]`中的一个数
# 1008. Construct Binary Search Tree from Preorder Traversal
分区间构造
# 1009. Complement of Base 10 Integer
构造全`1`异或
# 1010. Pairs of Songs With Total Durations Divisible by 60
求余的`two sum`
# 1011. Capacity To Ship Packages Within D Days
二分判断，求最小满足的
# 1012. Numbers With Repeated Digits
数位`dp`
# 1013. Partition Array Into Three Parts With Equal Sum
累加到`sum/3`，计数
# 1014. Best Sightseeing Pair
记录左边的`max`
# 1015. Smallest Integer Divisible by K
看某个余数是否已经出现，出现过说明要开始循环节了

除去`2`和`5`，其他都有解

另有等价的两个式子，后面的式子可以解决溢出问题
``` java
while (x % k != 0) {
    x = x * 10 + 1;
}
```
``` java
while (x % k != 0) {
    x = x % k;
    x = x * 10 + 1;
}
```
# 1016. Binary String With Substrings Representing 1 To N
`s`为`1000`位，将`s`以`1`开头的且长度小于`32`，值小于等于`n`的全放到`set`里，最后看`size`和`n`是否相等

另外考虑`s`的长度限制了表示的数，因此直接从`1`到`n`遍历，很快会有不能表示的数
# 1017. Convert to Base -2
考虑当前为时负还是正，把当前位置的影响加回去，如果为正则减`1`，为负加`1`
# 1018. Binary Prefix Divisible By 5
用余数进行后面的计算防止溢出
# 1019. Next Greater Node In Linked List
单调栈
# 1020. Number of Enclaves
每次`dfs`统计个数，并记录该联通块是否应该加入结果

也可以将最外圈的先加入，再从最外圈的进行`bfs`
# 1021. Remove Outermost Parentheses
`count`记录，将一头一尾去掉即可
# 1022. Sum of Root To Leaf Binary Numbers
递归路径，记录每个路径的值
# 1023. Camelcase Matching
依次比较
# 1024. Video Stitching
贪心每一轮找能更新的最大的值
# 1025. Divisor Game
当为偶数时，则一直拿`1`即可获胜，奇数拿一次变成偶数，对方获胜
# 1026. Maximum Difference Between Node and Ancestor
记录遍历到的最大值最小值，每次拿出来与当前节点比较
# 1027. Longest Arithmetic Sequence
`dp[i][diff]`，表示到`i`位置，`diff`差值的最大长度
``` java
dp[i][diff] = Math.max(dp[i][diff], dp[j][diff] + 1)
```
# 1028. Recover a Tree From Preorder Traversal
先把每个点的深度记下来，然后每次找是否存在深度一样的点，分别放置左右节点
# 1029. Two City Scheduling
假设全部人都取`b`，现在选一半的人去`a`，最好选`cost[i][0]-cost[i][1]`最小的
# 1030. Matrix Cells in Distance Order
从初始点开始向外`bfs`
# 1031. Maximum Sum of Two Non-Overlapping Subarrays
前缀和，记录到某个位置长为`l`的最大值，从后遍历，记录`m`长度最大值
# 1032. Stream of Characters
从单词最后一个字符构建`trie`树