# 301. Remove Invalid Parentheses
统计需要删除的左右括号数，递归的删除，删除完后看是否时满足合法括号的

统计时候，若左边未出现，则右括号均应该删除

删除给定一个起始点，之后的递归都从此点开始

记录重复元素，跳过
# 303. Range Sum Query - Immutable
记录前缀和
# 304. Range Sum Query 2D - Immutable
记录二维点的前缀和
# 306. Additive Number
注意到确定了前两个值便可以推导出是否是`true`
> 因此遍历前两个值的位置最多的位置，然后判断是否可行

> 采用`long`避免溢出

> `0`的位置不能在开头
# 307. Range Sum Query - Mutable
线段树
> 注意查找边界

> 更新时用了差值，所以要记得最后更新`nums`
# 309. Best Time to Buy and Sell Stock with Cooldown
动态规划
* `0`表示刚卖出
* `1`表示持有（买入）
* `2`表示冷冻期
注意这里多了冷冻期的状态，因此不持有变为两个状态，一个是刚卖出，一个是冷冻期
# 310. Minimum Height Trees
用邻接矩阵构造图，记录每个点的度数，将边缘度数`1`的去除掉，直到剩下最多最后两个点
# 312. Burst Balloons
直接搜索每次拿出一个（将nums减取一个后进入下层递归）遍历所有情况的思路会超时

上面的方法不好加记忆，因此考虑一个区间的递归左右两边，加上记忆能够通过

或者直接`dp`
``` java
dp[i][j] = dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]
```
需要注意先求的`dp`要小于大的区间，因此用固定长度来遍历求解所有小的区间
> 另外左右两边的`1`可以当作哨兵加入数组
# 313. Super Ugly Number
跟[264](https://github.com/humwawe/leetcode/blob/master/201-300.md#264-ugly-number-ii)思路一样，记录下标求当前最小的一个
# 315. Count of Smaller Numbers After Self
暴力超时

考虑将后面的元素放入一个有序列表中，对新元素进行二分查找并且插入，插入位置便是求解值 
# 316. Remove Duplicate Letters
用栈维护整个结果，如果当前的值大于栈顶即可以直接放进去，如果当前值小于栈顶，说明栈顶可能可以不要，而不要的依据便是后面是否还有栈顶的这个元素
# 318. Maximum Product of Word Lengths
将每个元素排序后放入`set`中，然后遍历每个`set`，找没有交集，乘积最大的元素

交集可以用`retainAll()`，但是元set就改变了需要注意，另外取`set`的时候也要新`new`一个使得原`set`不变

在判断是否重复可以使用位运算，判重就可以直接相与，然后与`0`比较
``` java
int wlength = words.length;
int[] arr = new int[wlength];
for(int i = 0; i < wlength; ++i){
    int length = words[i].length();
    for(int j = 0; j < length; ++j){
        arr[i] |= 1 << (words[i].charAt(j) - 'a');
    }
}
int ans = 0;
for(int i = 0; i < wlength; ++i){
    for(int j = i + 1; j < wlength; ++j){
        if((arr[i] & arr[j]) == 0){
            int k = words[i].length() * words[j].length();
            ans = ans < k ? k : ans;
        }
    }
}
return ans;
```
# 319. Bulb Switcher
直接遍历肯定超时

统计当前数的因子个数，为奇数就会亮，也会超时

考虑因子个数会发现当数为平方数的时候因子个数奇数，因此平方数会亮起来，直接求平方根就是平方数的个数
# 321. Create Maximum Number
从第一个当中抽出`0`到`k`个元素，则从第二个中抽出`k-i`，此时考虑抽出`i`个元素的最大值，和合并起来的最大值

抽出`i`个元素的最大值可以用`stack`来操作，当某个元素大于栈顶后考虑是否能将其弹出，弹出的时机是剩下的元素和当前栈顶的元素满足`i`个

合并起来要注意当两个元素想等时候移动哪一个指针，要看后面的元素哪个大
# 322. Coin Change
类似图的方法去`bfs`搜索，每次将可能的值放到队列中，需要记录已放过的值，避免重复计算

也可以用dp，跟完全背包问题很像`dp[i]=Math.min(dp[i],dp[i-coin]+1)`
``` java
dp[0] = 0;
for (int i = 1; i <= amount; ++i) {
    dp[i] = Integer.MAX_VALUE;
    for (int coin : coins) {
        if (i - coin >= 0 && dp[i - coin] != Integer.MAX_VALUE) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
}
```
# 324. Wiggle Sort II
排序后进行穿插，穿插的时候从后向前，可以避免`[4,5,5,6]`这种错误
> 穿插位置可以是`len`和`(len-1)/2`

考虑O(n)的复杂度，使E用快排思路找到中位数，然后构造答案
# 326. Power of Three
循环可以解决

不用循环考虑2的幂次是第一位为`1`，所以对`3`来说，可以转换为`3`进制后判断第一位为`1`且其余为`0`（不含`2`），转换之后也可以用正则匹配
``` java
Integer.toString(n, 3);
```

`3`的幂次的质因子只有`3`，所以还可以用`int`的最大`3`次幂来对`n`求余
``` java
1162261467 % n == 0;
```
# 327. Count of Range Sum
直接O(n^2)比较直观

求出前缀和，然后用`tree map`来维护前缀和

`sum[i] - x >= lower && sum[i] - x <= upper`

所以 `sum[i] - upper <= x <=sum[i] - lower`
`x`代表的是`sum[j]`，每次放入`map`中，每次统计多少个`sub map`满足

可以利用分治的思想，没太看懂
# 328. Odd Even Linked List
一个一个往后推就可以了
# 329. Longest Increasing Path in a Matrix
记忆化的递归，注意求过了的值不需要在计算了，`dfs`的时候不需要用`visit`因为有大于的判断所以不会循环递归
> 记忆化，不为`0`说明已经求到了该点的最大值
# 330. Patching Array
用一个区间来记录当前能够遍历到的区间，考虑当前数组的值如果大于当前遍历的元素，则有空的区间需要填充，如果小于则可以直接延伸，遍历的值直接使用区间的后一个元素
# 331. Verify Preorder Serialization of a Binary Tree
遍历每个元素，查看节点和叶子的差值状态，不满足时即可返回

用递归的方法，要注意考虑哪些点是可以分开两棵子树的，这个剪枝能保证不超时
# 332. Reconstruct Itinerary
`dfs`，考虑用`map`来存每个元素和对应的目的地（优先级队列），遍历时直接取出来，不用每一层都全遍历
> 因为一定合理，所以每次怎么能直接拿出那个元素较小就可以了，`dfs`里也就不需要那么多判断
# 334. Increasing Triplet Subsequence
`one`始终记录最小元素，`two`为某个子序列里第二大的数

接下来不断更新`one`，同时保持`two`尽可能的小

如果下一个元素比`two`大，说明找到了三元组

如果空间够多，可以考虑计算每个点前面是否有小于的，后面是否有大于的
# 335. Self Crossing
考虑相交的三种情况，利用滑动的思想用前几个对当前进行判断，对每一个进行判断即可