# 201. Bitwise AND of Numbers Range
一个一个相与就可以了

`n & (n - 1)`其实是去掉最右边的一个`1`，当去完了可以直接返回`0`了

考虑其实求的是左边的有多少位相同（如果二进制位个数不同，`m`左边都是`0`，最后就是`0`），所以考虑位数相同的时候左边有多少相等
``` java
while(m != n) {
    m >>= 1;
    n >>= 1;
    i++;
}
return m << i;
```
# 202. Happy Number
一直循环，记录出现的数字，如果再次出现说明不是，若出现为`1`则返回
# 203. Remove Linked List Elements
递归求解
# 204. Count Primes
厄拉多塞筛法
>`2`是第一个质数，然后把`n`以内所有`2`的倍数划去。`2`后面紧跟的数即为下一个质数`3`，然后把`3`所有的倍数划去，依此类推
# 205. Isomorphic Strings
正反两次遍历，用`map`维护对应关系（也可以直接两个`map`，遍历时维护两个`map`的值）

也可以用一个，当没有`key`时，看是否已经有`value`了（有，说明已经有另外的`key`和`value`对应）
``` java
for (int i = 0; i < s.length(); i++) {
    char ss = s.charAt(i);
    char tt = t.charAt(i);
    if (map.containsKey(ss)) {
        if (map.get(ss) != tt) {
            return false;
        }
    } else {
        if (map.containsValue(tt)) {
            return false;
        }
        map.put(ss, tt);
    }
}
```
# 206. Reverse Linked List
递归，每次必须把`head`的`next`置为空，否则会引起循环

考虑下一个节点递归完后，实际上`head`仍然指向第二个节点，因此直接把这个节点指向`head`即可，`head`仍然需要再指向空
``` java
ListNode p = reverseList(head.next);
head.next.next = head;
head.next = null;
return p;
```
# 207. Course Schedule
先构建一个图的结构，可以用`map`存储，`dfs`遍历，看是否遇到了之前标记为`-1`的点，若此点遍历完都没有环，则标记为`1`

另外可以考虑拓扑结构的出入度，
* 统计每个课指向次数，初始指向次数为`0`的肯定是安全
* 将所有指向度数为`0`的放入队列，依次弹出，将指向他们的节点的度数`-1`
* 加入度数是`0`的节点
* 判断是否有度数未减到`0`的节点
# 208. Implement Trie (Prefix Tree)
定义节点类型
``` java
class TrieNode {
    TrieNode[] child;
    boolean is_end;
}
```
根节点为空，向下延申
# 209. Minimum Size Subarray Sum
遍历，以该点位轴，看需要左边什么地方，当超过了当前最好值（最短宽度），剪枝

可以用滑动窗口的思想，右边使得`sum`增大，右指针先移动直到区间和大于等于`s`，再移动左边直到`sum`小于`s`，继续移动右边直到大于等于`s`
``` java
while (right < nums.length) {
    if (sum < s) {
        sum += nums[right];
        right++;
    }
    while (sum >= s) {
        res = Math.min(res, right - left);
        sum -= nums[left];
        left++;
    }
}
```
# 210. Course Schedule II
和[207](#207-course-schedule)思路一样，可以递归的时候在最后没问题加入`list`

这里使用了度数，将`0`度元素加入`queue`，依次遍历，在对每个`0`遍历的时候，将指向他们的节点度数`-1`
>为提高效率，可以维护一个指向该节点的`list`，存在`map`中，每次的`0`度元素拿出来一个`list`操作