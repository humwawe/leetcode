# 201. Bitwise AND of Numbers Range
一个一个相与就可以了

`n & (n - 1)`其实是去掉最右边的一个`1`，当去完了可以直接返回`0`了

考虑其实求的是左边的有多少位相同（如果二进制位个数不同，`m`左边都是`0`，最后就是`0`），所以考虑位数相同的时候左边有多少相等
``` java
while(m != n) {
    m >>= 1;
    n >>= 1;
    i++;
}
return m << i;
```
# 202. Happy Number
一直循环，记录出现的数字，如果再次出现说明不是，若出现为`1`则返回
# 203. Remove Linked List Elements
递归求解
# 204. Count Primes
厄拉多塞筛法
>`2`是第一个质数，然后把`n`以内所有`2`的倍数划去。`2`后面紧跟的数即为下一个质数`3`，然后把`3`所有的倍数划去，依此类推
# 205. Isomorphic Strings
正反两次遍历，用`map`维护对应关系（也可以直接两个`map`，遍历时维护两个`map`的值）

也可以用一个，当没有`key`时，看是否已经有`value`了（有，说明已经有另外的`key`和`value`对应）
``` java
for (int i = 0; i < s.length(); i++) {
    char ss = s.charAt(i);
    char tt = t.charAt(i);
    if (map.containsKey(ss)) {
        if (map.get(ss) != tt) {
            return false;
        }
    } else {
        if (map.containsValue(tt)) {
            return false;
        }
        map.put(ss, tt);
    }
}
```
# 206. Reverse Linked List
递归，每次必须把`head`的`next`置为空，否则会引起循环

考虑下一个节点递归完后，实际上`head`仍然指向第二个节点，因此直接把这个节点指向`head`即可，`head`仍然需要再指向空
``` java
ListNode p = reverseList(head.next);
head.next.next = head;
head.next = null;
return p;
```
# 207. Course Schedule
先构建一个图的结构，可以用`map`存储，`dfs`遍历，看是否遇到了之前标记为`-1`的点，若此点遍历完都没有环，则标记为`1`

另外可以考虑拓扑结构的出入度，
* 统计每个课指向次数，初始指向次数为`0`的肯定是安全
* 将所有指向度数为`0`的放入队列，依次弹出，将指向他们的节点的度数`-1`
* 加入度数是`0`的节点
* 判断是否有度数未减到`0`的节点
# 208. Implement Trie (Prefix Tree)
定义节点类型
``` java
class TrieNode {
    TrieNode[] child;
    boolean is_end;
}
```
根节点为空，向下延申
# 209. Minimum Size Subarray Sum
遍历，以该点位轴，看需要左边什么地方，当超过了当前最好值（最短宽度），剪枝

可以用滑动窗口的思想，右边使得`sum`增大，右指针先移动直到区间和大于等于`s`，再移动左边直到`sum`小于`s`，继续移动右边直到大于等于`s`
``` java
while (right < nums.length) {
    if (sum < s) {
        sum += nums[right];
        right++;
    }
    while (sum >= s) {
        res = Math.min(res, right - left);
        sum -= nums[left];
        left++;
    }
}
```
# 210. Course Schedule II
和[207](#207-course-schedule)思路一样，可以递归的时候在最后没问题加入`list`

这里使用了度数，将`0`度元素加入`queue`，依次遍历，在对每个`0`遍历的时候，将指向他们的节点度数`-1`
>为提高效率，可以维护一个指向该节点的`list`，存在`map`中，每次的`0`度元素拿出来一个`list`操作
# 211. Add and Search Word - Data structure design
用`map`来保存，`string`的长度为`key`

也可以考虑前缀树来存储[208](#208-implement-trie-(prefix-tree))
# 212. Word Search II
如果使用[79](https://github.com/humwawe/leetcode/blob/master/1-100.md#79-word-serch)，则超时

考虑使用前缀树，将所有单词加入树中，遍历`board`，看是否当前单词能在树中找到

更好的前缀树结构，只需像链表那样传入单个`root`，并且该节点如果是结尾就保存到此位置的单词
``` java
class TrieNode2 {
    String word;
    TrieNode[] next = new TrieNode[26];

    TrieNode add(char chr) {
        if (next[chr - 'a'] != null) {
            return next[chr - 'a'];
        }
        next[chr - 'a'] = new TrieNode();
        return next[chr - 'a'];
    }

    boolean ifExists(char chr) {
        return next[chr - 'a'] != null;
    }
}
for (int i = 0; i < words.length; i++) {
    TrieNode node = root;
    for (int j = 0; j < words[i].length(); j++) {
        node = node.add(words[i].charAt(j));
    }
    node.word = words[i];
}
```
# 213. House Robber II
考虑偷第一家和不偷第一家的情况，遍历`[0~n-1]`和`[1~n]`
> 两个`dp`初始化不一样，结束条件不一样，比较难通过增加一个`dp`状态一次解决。当然也可以解决，就是增加一个状态，两者互相不干扰
# 214. Shortest Palindrome
要在前面加，说明需求得从第一个开始的最长字符串，将之后的颠倒加入前面

从头和尾向中间判断回文会超时，采用从中间往两头由于案例的设计可以更快判断出来，勉强通过，更好的方法是使用`kmp`

在每一步把后面的元素直接先加到`StringBuilder`中，最后直接连接，而不是每次记录`len`的长度会更快不至于超时
``` java
public String shortestPalindrome(String s) {
        StringBuilder str = new StringBuilder("");
        String result = null;
        for(int i = s.length() - 1; i > 0; i--) {
            if(isPalindrome(s, 0, i)) {
                break;
            }
            str.append(s.charAt(i));
        }
        result = str.toString() + s;
        return result;
    }
public Boolean isPalindrome(String s, int start, int tail) {
    while(tail > start) {
        if(s.charAt(start++) != s.charAt(tail--)) {
            return false;
        }
    }
    return true;
}
```
# 215. Kth Largest Element in an Array
* 排序
>可以直接排序取第`k`大的元素

* 最小堆
>维护一个前`k`大的最小堆，代码可以优化
``` java
for(int num : nums){ 
   queue.add(num);
   if(queue.size() > k) queue.poll();           
}
```
* 桶排序
>分成`max-min+1`个桶，以`nums[i]-min`作为`bucket`索引，记录每个桶的元素次数，从后往前数每个桶的元素个数
``` java
int[] bucket = new int[max - min + 1];
for (int i = 0; i < nums.length; i++) {
    bucket[nums[i] - min]++;
}
int count = 0;
for (int j = bucket.length - 1; j >= 0; j--) {
    count += bucket[j];
    if (count >= k) return j + min;
}
```
* 快排
> 确定一个位置看是否是大于`k`或小于`k`，再分治
# 216. Combination Sum III
递归
# 217. Contains Duplicate
用set保存经历过的元素

或者排序看是否有地方有重复
# 218. The Skyline Problem
遍历坐标轴可能的位置，选取最大的高度，若与上个高度不一致，则记录
> 高度的维护采用最大堆，入点加入，出点删去