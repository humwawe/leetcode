# 601. Human Traffic of Stadium
`a`作为最小值，中间值，最大值的情况
``` sql
SELECT distinct a.*
FROM stadium as a,stadium as b,stadium as c
where ((a.id = b.id-1 and b.id+1 = c.id) or
       (a.id-1 = b.id and a.id+1 = c.id) or
       (a.id-1 = c.id and c.id-1 = b.id))
  and (a.people>=100 and b.people>=100 and c.people>=100)
order by a.id;
```
# 605. Can Place Flowers
每`3`个可以放一个，注意开头和结尾的情况，考虑在开头末尾加`0`，因此初始化时`count=1`，结尾`count/2`
# 606. Construct String from Binary Tree
考虑右边为空的时候，可以省略括号，左边为空时不能省略
``` java
public String tree2str(TreeNode t) {
    if(t==null)
        return "";
    if(t.left==null && t.right==null)
        return t.val+"";
    if(t.right==null)
        return t.val+"("+tree2str(t.left)+")";
    return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";   
}
```
# 609. Find Duplicate File in System
用`map`存储内容对应的路径，如果存在两个以上则返回答案
# 611. Valid Triangle Number
排序后三重循环判断a+b>c，O(N^3)

由于排序，查找c的时候用二分可以降到O(N^2logN)

利用双指针降到O(N^2)，从后往前固定最大值，考虑左边界和右边界
``` java
for (int i = n - 1; i >= 2; --i) {
    int l = 0, r = i - 1;
    while (l < r) {
        if (nums[l] + nums[r] > nums[i]) {
            res += r - l;
            --r;
        } else {
            ++l;
        }
    }
}
```
# 617. Merge Two Binary Trees
递归左右两边即可
# 620. Not Boring Movies
`mod`求奇偶
``` sql
select *
from cinema
where mod(id, 2) = 1 and description != 'boring'
order by rating DESC ;
```
# 621. Task Scheduler
最小的次数为`(max-1)*(n+1)+1`
> A->X->X->A->X->X->A

若某个任务跟`A`一样多，则次数需要加`1`
> A->B->X->A->B->X->A->B

若空位置插满后还有，就可以随便继续插入
``` java
Arrays.sort(counts);
int maxCount = counts[25];
int retCount = (maxCount - 1) * (n + 1) + 1;
int i = 24;
while (i >= 0 && counts[i] == maxCount) {
    retCount++;
    i--;
}
return Math.max(retCount, tasks.length);
```
# 622. Design Circular Queue
利用数组求余
# 623. Add One Row to Tree
广度优先遍历到层数添加即可，也可以深度递归插入
``` java
public void insert(int val, TreeNode node, int depth, int n) {
    if (node == null)
        return;
    if (depth == n - 1) {
        TreeNode t = node.left;
        node.left = new TreeNode(val);
        node.left.left = t;
        t = node.right;
        node.right = new TreeNode(val);
        node.right.right = t;
    } else {
        insert(val, node.left, depth + 1, n);
        insert(val, node.right, depth + 1, n);
    }
}
```
# 626. Exchange Seats
改变`id`后排序
``` sql
SELECT (CASE 
            WHEN MOD(id,2) = 1 AND id = (SELECT COUNT(*) FROM seat) THEN id
            WHEN MOD(id,2) = 1 THEN id+1
            ElSE id-1
        END) AS id, student
FROM seat
ORDER BY id;
```
# 627. Swap Salary
`if`表达式
``` sql
UPDATE
salary 
SET sex = IF(sex = 'm','f','m')
```
# 628. Maximum Product of Three Numbers
排序后要么是最后三个，要么是前两个（负数）和最后一个
> 也可以一次遍历记录这几个值
``` java
int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
for (int n: nums) {
    if (n <= min1) {
        min2 = min1;
        min1 = n;
    } else if (n <= min2) {
        min2 = n;
    }
    if (n >= max1) {
        max3 = max2;
        max2 = max1;
        max1 = n;
    } else if (n >= max2) {
        max3 = max2;
        max2 = n;
    } else if (n >= max3) {
        max3 = n;
    }
}
return Math.max(min1 * min2 * max1, max1 * max2 * max3);
```
# 629. K Inverse Pairs Array
动态规划，`dp[i][j]`表示`i`个数`j`个逆序对的排列数，此时考虑`i`的不同位置
* 放最后逆序对不变`dp[i-1][j]`
* 放倒数第二个，多一个逆序对，由`dp[i-1][j-1]`转移过来
继续整个过程，有
``` java
dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][j-i+1]
```
复杂度`O(N^2*K)`，观察递推式
``` java
dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][j-i+1]
dp[i][j-1]=dp[i-1][j-1]+dp[i-1][j-2]+...+dp[i-1][j-i]
dp[i][j]-dp[i][j-1]=dp[i-1][j]-dp[i-1][j-i]
dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
```
用`dp[i][j-1]`代替了部分和，有点像前缀和
# 630. Course Schedule III
贪心的思路，按结束时间排序，记录要上课程的长度，对当前课程，如果不能上了，则考虑去掉最耗时的一门
>比如`[5,5]`,`[4,6]`两门课，上了`[5,5]`后，再上`[4,6]`肯定不行，既然两个只能选一个，肯定选最短的那个`[4,6]`
# 632. Smallest Range Covering Elements from K Lists
将所有元素放入`treeset`中，对每个元素，考虑其为左端点的时候，右端点的位置，剪枝是当`r-l>res`时`break`

考虑展平，排序并记录每个元素属于哪一行，找某个区间框住所有的行，可以采用双指针
``` java
List<int[]> list = new ArrayList<>();
for (int i = 0; i < m; ++i) {
    List<Integer> num = nums.get(i);
    for (int n : num) {
        list.add(new int[] {n, i});
    }
}
Collections.sort(list, (num1, num2) -> (num1[0] - num2[0]));
int n = list.size(), lo = 0, interval = Integer.MAX_VALUE, diff = 0;
int[] which = new int[m];
int[] ans = new int[2];
for (int hi = 0; hi < n; ++hi) {
    diff += which[list.get(hi)[1]]++ == 0 ? 1 : 0;
    while (diff == m && lo <= hi) {
        int i = list.get(lo)[0], j = list.get(hi)[0];
        if (j - i < interval) {
            interval = j - i;
            ans = new int[] {i, j};
        }
        if (--which[list.get(lo)[1]] == 0) {
            --diff;
        }
        ++lo;
    }
}
return ans;
```
考虑`K`路指针的方案，将每个数组的头放入`treeset`中，找出最大值和最小值去更新结果，然后去掉最小值，用该行的下一个元素去替换，直到到达某个数组的末尾
# 633. Sum of Square Numbers
遍历`a`到，看是否刚好有`b`，注意`a*a`可能溢出，用`long`

也可以用双指针
``` java
int i = 0, j = (int) Math.sqrt(target);
while (i <= j) {
    int powSum = i * i + j * j;
    if (powSum == target) {
        return true;
    } else if (powSum > target) {
        j--;
    } else {
        i++;
    }
}
```
费马平方和定理
>一个非负整数`c`能够表示为两个整数的平方和，当且仅当`c`的所有形如`4k+3`的质因子的幂次均为偶数
# 636. Exclusive Time of Functions
用栈模拟，把中间的时间放进去，在遇到`end`的时候先`pop`中间耗时

考虑方进入`id`和开始时间，每次`pop`的时候，如果栈顶不为空，将栈顶减去当前耗时
``` java
Deque<int[]> st = new ArrayDeque<>();
for(String log : logs) {
    String[] stamp = log.split(":");
    if(stamp[1].equals("start"))
        st.push(new int[]{Integer.parseInt(stamp[0]), Integer.parseInt(stamp[2])});
    else {
        int[] fun = st.poll();
        int exectime = Integer.parseInt(stamp[2]) - fun[1] + 1;
        ret[fun[0]] += exectime;
        if(!st.isEmpty())
            ret[st.peek()[0]] -= exectime;
    }
}
```
# 637. Average of Levels in Binary Tree
层次遍历，记录`sum`和`size`
# 638. Shopping Offers
记忆化递归，考虑取不同方案的最好情况
> 注意`res`的初始化可以为`dot`值，将`price`当成特殊的大礼包放入`special`会超时
# 639. Decode Ways II
考虑前一个不同的情况进行递推即可
# 640. Solve the Equation
分别计算两边`x`的系数和数字，只有`+-`，可以在负号前添加正号，按正号划分
> 注意`x`和`-x`
# 641. Design Circular Deque
使用`(下标 + 容量 +/- 1) % 容量`取于的方式实现下标循环
# 643. Maximum Average Subarray I
移动窗口
# 645. Set Mismatch
另开数组记录每个位置出现的次数

或者交换的思路
``` java
for (int i = 0; i < nums.length; i++) {
    while (nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]) {
        swap(nums, i, nums[i] - 1);
    }
}
for (int i = 0; i < nums.length; i++) {
    if (nums[i] != i + 1) {
        return new int[]{nums[i], i + 1};
    }
}
```
# 646. Maximum Length of Pair Chain
排序后，`dp`看前面的项是否与当前项可以递推

另外贪心
``` java
Arrays.sort(pairs,(a,b)-> a[1]-b[1]);
int res = 1,tmp = pairs[0][1];
for(int i = 1;i < pairs.length;i++){
    if(pairs[i][0] > tmp){
         res++;
         tmp = pairs[i][1];
    }
}
return res;
```
# 647. Palindromic Substrings
记录`dp[i][j]`表示是否两个位置间是是否回文，用不同的长度去计算

也可以用中心去扩散
``` java
for (int i = 0; i < s.length(); i++){
    result += countSegment(s, i, i);
    result += countSegment(s, i, i + 1);
}
return result;

private int countSegment(String s, int start, int end){
    int cnt = 0;
    while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)){
        cnt++;
        start--;
        end++;
    }
    return cnt;
}
```
# 648. Replace Words
排序后二分搜索，库函数`Collections.binarySearch`将返回搜索的位置，如果返回负数则对应正数应该的位置，用此位置检查前一个位置是否可行
>对于`[b,d]`，查询`a`返回`-1`，查询`c`返回`-2`，查询`e`返回`-3`

一般的思路是构造前缀树
``` java
class TrieNode {
    boolean isLeaf;
    TrieNode[] children = new TrieNode[26];
}

private void add(List<String> dict) {
    for(String d : dict){
        TrieNode node = root;
        for (char c : d.toCharArray()) {
            if (node.children[c - 'a'] == null) {
                node.children[c - 'a'] = new TrieNode();
            }
            node = node.children[c - 'a'];
        }
        node.isLeaf = true;
    }
}
```
# 649. Dota2 Senate
模拟整个投票过程
# 650. 2 Keys Keyboard
记忆化递归，考虑复制粘贴合二为一与粘贴两种情况，因为不能一直复制，所以复制必然带一个粘贴，将其当成一个操作

另外比较数学的方式是，注意
> 只能复制全部的数，不能回退，找到所有因子，然后复制`n/i-1`次
``` java
for (int i = n - 1; i > 1; --i) {
    if (n % i == 0) {
        res = min(res, minSteps(n / i) + i);
    }
}
```
可以证明最大的因子是最优的情况
``` java
for (int i = n / 2; i > 1; i--) {
   if (n % i == 0) {
       return minSteps(i) + n / i;
   }
}
```
# 652. Find Duplicate Subtrees
序列化节点，记录每个节点的字串个数，当某一次为`1`的时候加入结果
# 653. Two Sum IV - Input is a BST
把遍历遇到的数加入`set`中，后续检查`k-root.var`是否在`set`中
# 654. Maximum Binary Tree
找到最大的元素位置，递归两边的数组
# 655. Print Binary Tree
求高度，求长度，将每个元素递归的往中间放
# 657. Robot Return to Origin
计数即可
# 658. Find K Closest Elements
二分找插入的位置，向前和后移动得到`l`和`r`的位置，都取开区间
> 位置不好控制

考虑自定义排序
``` java
Collections.sort(arr, (a,b) -> a == b ? a - b : Math.abs(a-x) - Math.abs(b-x));
arr = arr.subList(0, k);
Collections.sort(arr);
```
另外二分直接找最左的节点
``` java
int start = 0;
int end = arr.length-k;
while(start < end) {
    int mid = (start+end)/2;
    if(Math.abs(arr[mid]-x) > Math.abs(arr[mid+k]-x)) {
        start = mid+1;
    }else {
        end = mid;
    }
}
```
# 659. Split Array into Consecutive Subsequences
遇到一个元素，看是否能加入前面的序列，否则开一个三个元素的序列，并将后一个需要值加`1`