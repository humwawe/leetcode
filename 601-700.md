# 601. Human Traffic of Stadium
`a`作为最小值，中间值，最大值的情况
``` sql
SELECT distinct a.*
FROM stadium as a,stadium as b,stadium as c
where ((a.id = b.id-1 and b.id+1 = c.id) or
       (a.id-1 = b.id and a.id+1 = c.id) or
       (a.id-1 = c.id and c.id-1 = b.id))
  and (a.people>=100 and b.people>=100 and c.people>=100)
order by a.id;
```
# 605. Can Place Flowers
每`3`个可以放一个，注意开头和结尾的情况，考虑在开头末尾加`0`，因此初始化时`count=1`，结尾`count/2`
# 606. Construct String from Binary Tree
考虑右边为空的时候，可以省略括号，左边为空时不能省略
``` java
public String tree2str(TreeNode t) {
    if(t==null)
        return "";
    if(t.left==null && t.right==null)
        return t.val+"";
    if(t.right==null)
        return t.val+"("+tree2str(t.left)+")";
    return t.val+"("+tree2str(t.left)+")("+tree2str(t.right)+")";   
}
```
# 609. Find Duplicate File in System
用`map`存储内容对应的路径，如果存在两个以上则返回答案
# 611. Valid Triangle Number
排序后三重循环判断a+b>c，O(N^3)

由于排序，查找c的时候用二分可以降到O(N^2logN)

利用双指针降到O(N^2)，从后往前固定最大值，考虑左边界和右边界
``` java
for (int i = n - 1; i >= 2; --i) {
    int l = 0, r = i - 1;
    while (l < r) {
        if (nums[l] + nums[r] > nums[i]) {
            res += r - l;
            --r;
        } else {
            ++l;
        }
    }
}
```
# 617. Merge Two Binary Trees
递归左右两边即可
# 620. Not Boring Movies
`mod`求奇偶
``` sql
select *
from cinema
where mod(id, 2) = 1 and description != 'boring'
order by rating DESC ;
```
# 621. Task Scheduler
最小的次数为`(max-1)*(n+1)+1`
> A->X->X->A->X->X->A

若某个任务跟`A`一样多，则次数需要加`1`
> A->B->X->A->B->X->A->B

若空位置插满后还有，就可以随便继续插入
``` java
Arrays.sort(counts);
int maxCount = counts[25];
int retCount = (maxCount - 1) * (n + 1) + 1;
int i = 24;
while (i >= 0 && counts[i] == maxCount) {
    retCount++;
    i--;
}
return Math.max(retCount, tasks.length);
```
# 622. Design Circular Queue
利用数组求余
# 623. Add One Row to Tree
广度优先遍历到层数添加即可，也可以深度递归插入
``` java
public void insert(int val, TreeNode node, int depth, int n) {
    if (node == null)
        return;
    if (depth == n - 1) {
        TreeNode t = node.left;
        node.left = new TreeNode(val);
        node.left.left = t;
        t = node.right;
        node.right = new TreeNode(val);
        node.right.right = t;
    } else {
        insert(val, node.left, depth + 1, n);
        insert(val, node.right, depth + 1, n);
    }
}
```
# 626. Exchange Seats
改变`id`后排序
``` sql
SELECT (CASE 
            WHEN MOD(id,2) = 1 AND id = (SELECT COUNT(*) FROM seat) THEN id
            WHEN MOD(id,2) = 1 THEN id+1
            ElSE id-1
        END) AS id, student
FROM seat
ORDER BY id;
```
# 627. Swap Salary
`if`表达式
``` sql
UPDATE
salary 
SET sex = IF(sex = 'm','f','m')
```
# 628. Maximum Product of Three Numbers
排序后要么是最后三个，要么是前两个（负数）和最后一个
> 也可以一次遍历记录这几个值
``` java
int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;
for (int n: nums) {
    if (n <= min1) {
        min2 = min1;
        min1 = n;
    } else if (n <= min2) {
        min2 = n;
    }
    if (n >= max1) {
        max3 = max2;
        max2 = max1;
        max1 = n;
    } else if (n >= max2) {
        max3 = max2;
        max2 = n;
    } else if (n >= max3) {
        max3 = n;
    }
}
return Math.max(min1 * min2 * max1, max1 * max2 * max3);
```
# 629. K Inverse Pairs Array
动态规划，`dp[i][j]`表示`i`个数`j`个逆序对的排列数，此时考虑`i`的不同位置
* 放最后逆序对不变`dp[i-1][j]`
* 放倒数第二个，多一个逆序对，由`dp[i-1][j-1]`转移过来
继续整个过程，有
``` java
dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][j-i+1]
```
复杂度`O(N^2*K)`，观察递推式
``` java
dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+...+dp[i-1][j-i+1]
dp[i][j-1]=dp[i-1][j-1]+dp[i-1][j-2]+...+dp[i-1][j-i]
dp[i][j]-dp[i][j-1]=dp[i-1][j]-dp[i-1][j-i]
dp[i][j]=dp[i][j-1]+dp[i-1][j]-dp[i-1][j-i]
```
用`dp[i][j-1]`代替了部分和，有点像前缀和