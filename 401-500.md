# 401. Binary Watch
对时和分分别求可能的值，然后合起来

可以遍历每个值，看是否使用`num`个灯
``` java
for (int h = 0; h < 12; h++) {
    for (int m = 0; m < 60; m++) {
        if (Integer.bitCount(h) + Integer.bitCount(m) == num) {
            result.add(String.format("%d:%02d", h, m));
        }
    }
}
```
也可以考虑从`n`个数中选`k`个
``` java
private void sub(int num, int start, int cnt, int[] stat){
    if(cnt == num){
        int hour = stat[0]*8+stat[1]*4+stat[2]*2+stat[3];
        int minu = stat[4]*32+stat[5]*16+stat[6]*8+stat[7]*4+stat[8]*2+stat[9];
        if(hour<12 && minu<60){
            String s = String.format("%d:%02d", hour, minu);
            res.add(s);
        }
        
        return;
    }
    
    for(int i=start; i<=(9-(num-cnt)+1); i++){
        stat[i] = 1;
        sub(num, i+1, cnt+1, stat);
        stat[i] = 0;
    }
}
```
# 402. Remove K Digits
从头到尾，如果前面的数大于后面的，说明该值是要被去掉的，重复这个过程即可
> 考虑效率上，若字符串是升序的，则`flag`为`false`，可以直接去掉后面几位，不用再循环

可以用一个栈来存应该放的元素，维护一个递增的栈
``` java
for (int i = 0; i < num.length(); i++) {
    while (k > 0 && !stack.isEmpty() && num.charAt(i) < stack.peek()) {
        stack.pop();
        k--;
    }
    stack.push(num.charAt(i));
}
```
# 403. Frog Jump
用一个`map`记录每个数可以跳多少步过来，然后对该数遍历可以跳到的位置，并把步数写到对应的数字中
> 本质上是动态规划

考虑用图的的层次遍历的方法，记录每个数跟上一次的步数，但是超内存了
# 404. Sum of Left Leaves
用一个标志记录当前节点是否是左节点，且是叶子节点

或者
``` java
if(root.left != null && root.left.left == null && root.left.right == null){
    res += root.left.val;
}
```
# 405. Convert a Number to Hexadecimal
可以使用库函数
* int to hex 
>`Integer.toHexString()`
* hex to int 
>`Integer.valueOf("12ff",16)`
# 406. Queue Reconstruction by Height
把每个`k`的值存起来（由大到小），然后取出来从头遍历插入对应的位置

其实是个排序问题
1. 按照先`h`降序，`k`升序排序
2. 遍历排序后的数组，根据`k`插入到`k`的位置上
``` java
Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
LinkedList<int[]> list = new LinkedList<>();
for (int[] i : people) {
    list.add(i[1], i);
}
```