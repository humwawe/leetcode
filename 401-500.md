# 401. Binary Watch
对时和分分别求可能的值，然后合起来

可以遍历每个值，看是否使用`num`个灯
``` java
for (int h = 0; h < 12; h++) {
    for (int m = 0; m < 60; m++) {
        if (Integer.bitCount(h) + Integer.bitCount(m) == num) {
            result.add(String.format("%d:%02d", h, m));
        }
    }
}
```
也可以考虑从`n`个数中选`k`个
``` java
private void sub(int num, int start, int cnt, int[] stat){
    if(cnt == num){
        int hour = stat[0]*8+stat[1]*4+stat[2]*2+stat[3];
        int minu = stat[4]*32+stat[5]*16+stat[6]*8+stat[7]*4+stat[8]*2+stat[9];
        if(hour<12 && minu<60){
            String s = String.format("%d:%02d", hour, minu);
            res.add(s);
        }
        
        return;
    }
    
    for(int i=start; i<=(9-(num-cnt)+1); i++){
        stat[i] = 1;
        sub(num, i+1, cnt+1, stat);
        stat[i] = 0;
    }
}
```
# 402. Remove K Digits
从头到尾，如果前面的数大于后面的，说明该值是要被去掉的，重复这个过程即可
> 考虑效率上，若字符串是升序的，则`flag`为`false`，可以直接去掉后面几位，不用再循环

可以用一个栈来存应该放的元素，维护一个递增的栈
``` java
for (int i = 0; i < num.length(); i++) {
    while (k > 0 && !stack.isEmpty() && num.charAt(i) < stack.peek()) {
        stack.pop();
        k--;
    }
    stack.push(num.charAt(i));
}
```
# 403. Frog Jump
用一个`map`记录每个数可以跳多少步过来，然后对该数遍历可以跳到的位置，并把步数写到对应的数字中
> 本质上是动态规划

考虑用图的的层次遍历的方法，记录每个数跟上一次的步数，但是超内存了
# 404. Sum of Left Leaves
用一个标志记录当前节点是否是左节点，且是叶子节点

或者
``` java
if(root.left != null && root.left.left == null && root.left.right == null){
    res += root.left.val;
}
```
# 405. Convert a Number to Hexadecimal
每四位进行转换成十六进制

可以使用库函数
* int to hex 
>`Integer.toHexString()`
* hex to int 
>`Integer.valueOf("12ff",16)`
# 406. Queue Reconstruction by Height
把每个`k`的值存起来（由大到小），然后取出来从头遍历插入对应的位置

其实是个排序问题
1. 按照先`h`降序，`k`升序排序
2. 遍历排序后的数组，根据`k`插入到`k`的位置上
``` java
Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
LinkedList<int[]> list = new LinkedList<>();
for (int[] i : people) {
    list.add(i[1], i);
}
```
# 407. Trapping Rain Water II
用接雨水的思路不能解决这个问题，但是用这个问题可以解决第一个接雨水问题
> 用优先队列存储边缘的点，再往里面推进，每次拿出最小的几个点，访问临近的点，并且保持水位不减小

如：

|1|2|3|4|5|
|:-:|:-:|:-:|:-:|:-:|
|10|3|5|2|4|

1. 把`10`跟`4`放入队列
2. 弹出`4`把访问`2`，`res += 4-2`，把`2`放入队列，其实放的是`4：max(4,2)`
3. 弹出`4`把访问`5`，把`5`放入队列，`max(5,4)`
4. 弹出`5`，访问`3`，`res += 5-3`，把`3`放入队列，其实放的是`5：max(5,3)`
5. 弹出`5`
6. 弹出`10`

同理可以推广到本题的`2`维上
# 409. Longest Palindrome
记录每个单词出现的次数，然后取所有偶数，如果有奇数的情况，最后加上一个
# 410. Split Array Largest Sum
暴力的方法超时了

考虑`dp`，`dp[i][j]`表示前`i`个划分成j份的结果，则`dp[len][m]`为答案
``` java
dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j - 1], sum[i] - sum[k]));
```
使用尝试二分试错，对某个值计算对应了多少个划分
``` java
//划分之后子数组最大值，大于数组中最大的一个元素，小于数组的总和
long l = 0;
long r = 0;
int n = nums.length;
//r是数组总和，l是数组中最大的值
for (int i = 0; i < n; i++) {
    r += nums[i];
    if (l < nums[i]) {
        l = nums[i];
    }
}
long ans = r;
while (l <= r) {
    //求出中间值mid，计算子数组和不大于mid时，能划分出几个子数组
    long mid = (l + r) >> 1;
    long sum = 0;
    int cnt = 1;//划分的子数组个数,初始值为1是因为，下面只在分割处加了1，分割1次，数组长度为2，所以初始值为1
    for (int i = 0; i < n; i++) {
        if (sum + nums[i] > mid) {
            cnt++;
            sum = nums[i];
        } else {
            sum += nums[i];
        }
    }
    if (cnt <= m) {//划分出来的子数组少于m个，说明mid值大了
        ans = Math.min(ans, mid);
        r = mid - 1;
    } else {//划分出来的子数组多于m个，说明mid值小了
        l = mid + 1;
    }
}
return (int) ans;
```
# 412. Fizz Buzz
循环判断即可
# 413. Arithmetic Slices
求出多少长度的等差数列，用公式可以求出有多少个，注意子数组连续所以可以直接求

考虑动态规划，`dp[i]`以某个点结束以`i`结束的序列有多少个

对`[1,2,3,4,5,6]`
* 以`A[2]`结尾的等差数列：`[1,2,3]`
* 以`A[3]`结尾的等差数列：`[1,2,3,4]`，`[2,3,4]`
* 以`A[4]`结尾的等差数列：`[1,2,3,4,5]`，`[2,3,4,5]`，`[3,4,5]`
> `dp[i]=dp[i-1]+1`
``` java
int[] dp = new int[A.length];
int sum = 0;
for (int i = 2; i < dp.length; i++) {
    if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
        dp[i] = 1 + dp[i - 1];
        sum += dp[i];
    }
}
return sum;
```
# 414. Third Maximum Number
优先级队列，每次看是否需要插入下一个元素

优先级队列可以放入重复元素，考虑使用`set`
``` java
TreeSet<Integer> set = new TreeSet<>();
for (Integer elem : nums) {
    set.add(elem);
    if (set.size() > 3) set.remove(set.first());
}

return set.size() < 3 ? set.last() : set.first();
```
