# 401. Binary Watch
对时和分分别求可能的值，然后合起来

可以遍历每个值，看是否使用`num`个灯
``` java
for (int h = 0; h < 12; h++) {
    for (int m = 0; m < 60; m++) {
        if (Integer.bitCount(h) + Integer.bitCount(m) == num) {
            result.add(String.format("%d:%02d", h, m));
        }
    }
}
```
也可以考虑从`n`个数中选`k`个
``` java
private void sub(int num, int start, int cnt, int[] stat){
    if(cnt == num){
        int hour = stat[0]*8+stat[1]*4+stat[2]*2+stat[3];
        int minu = stat[4]*32+stat[5]*16+stat[6]*8+stat[7]*4+stat[8]*2+stat[9];
        if(hour<12 && minu<60){
            String s = String.format("%d:%02d", hour, minu);
            res.add(s);
        }
        
        return;
    }
    
    for(int i=start; i<=(9-(num-cnt)+1); i++){
        stat[i] = 1;
        sub(num, i+1, cnt+1, stat);
        stat[i] = 0;
    }
}
```
# 402. Remove K Digits
从头到尾，如果前面的数大于后面的，说明该值是要被去掉的，重复这个过程即可
> 考虑效率上，若字符串是升序的，则`flag`为`false`，可以直接去掉后面几位，不用再循环

可以用一个栈来存应该放的元素，维护一个递增的栈
``` java
for (int i = 0; i < num.length(); i++) {
    while (k > 0 && !stack.isEmpty() && num.charAt(i) < stack.peek()) {
        stack.pop();
        k--;
    }
    stack.push(num.charAt(i));
}
```
# 403. Frog Jump
用一个`map`记录每个数可以跳多少步过来，然后对该数遍历可以跳到的位置，并把步数写到对应的数字中
> 本质上是动态规划

考虑用图的的层次遍历的方法，记录每个数跟上一次的步数，但是超内存了
# 404. Sum of Left Leaves
用一个标志记录当前节点是否是左节点，且是叶子节点

或者
``` java
if(root.left != null && root.left.left == null && root.left.right == null){
    res += root.left.val;
}
```
# 405. Convert a Number to Hexadecimal
每四位进行转换成十六进制

可以使用库函数
* int to hex 
>`Integer.toHexString()`
* hex to int 
>`Integer.valueOf("12ff",16)`
# 406. Queue Reconstruction by Height
把每个`k`的值存起来（由大到小），然后取出来从头遍历插入对应的位置

其实是个排序问题
1. 按照先`h`降序，`k`升序排序
2. 遍历排序后的数组，根据`k`插入到`k`的位置上
``` java
Arrays.sort(people, (o1, o2) -> o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
LinkedList<int[]> list = new LinkedList<>();
for (int[] i : people) {
    list.add(i[1], i);
}
```
# 407. Trapping Rain Water II
用接雨水的思路不能解决这个问题，但是用这个问题可以解决第一个接雨水问题
> 用优先队列存储边缘的点，再往里面推进，每次拿出最小的几个点，访问临近的点，并且保持水位不减小

如：

|1|2|3|4|5|
|:-:|:-:|:-:|:-:|:-:|
|10|3|5|2|4|

1. 把`10`跟`4`放入队列
2. 弹出`4`把访问`2`，`res += 4-2`，把`2`放入队列，其实放的是`4：max(4,2)`
3. 弹出`4`把访问`5`，把`5`放入队列，`max(5,4)`
4. 弹出`5`，访问`3`，`res += 5-3`，把`3`放入队列，其实放的是`5：max(5,3)`
5. 弹出`5`
6. 弹出`10`

同理可以推广到本题的`2`维上