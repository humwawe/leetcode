# 1103. Distribute Candies to People
模拟过程即可

数学方法，对于等差数列，求和为`(a1+an)/2*n`，从`1`加到`p`，最接近`c`的那个数为
```
p=(int)Math.sqrt(2*c+0.25)-0.5
```
# 1104. Path In Zigzag Labelled Binary Tree
找对称位置
# 1105. Filling Bookcase Shelves
`dp[i]`，表示以`i`结尾的最小高度，考虑把前几个放到一层之后的结果
# 1106. Parsing A Boolean Expression
找到最中间的括号部分，求解后，递归
> 跟[1096](https://github.com/humwawe/leetcode/blob/master/1001-1100.md#1096-brace-expansion-ii)思路一样
# 1108. Defanging an IP Address
替换即可
# 1109. Corporate Flight Bookings
区间赋值
# 1110. Delete Nodes And Return Forest
遍历得到删除后的结果，返回处理后的根节点
# 1111. Maximum Nesting Depth of Two Valid Parentheses Strings
按奇偶分
# 1114. Print in Order
使用`CountDownLatch`
# 1115. Print FooBar Alternately
生产消费者模型
# 1116. Print Zero Even Odd
使用信号量
# 1117. Building H2O
使用信号量
# 1122. Relative Sort Array
转换为`Integer`排序，或者用桶排序
# 1123. Lowest Common Ancestor of Deepest Leaves
返回节点和高度
# 1124. Longest Well-Performing Interval
转换为`1`和`-1`之后求前缀和，对每个`j`找`j-1`出现的最早位置，这一段肯定为`1`是满足的
# 1125. Smallest Sufficient Team
`01`背包问题，转换为位运算递推
# 1128. Number of Equivalent Domino Pairs
类似`A+B`问题
# 1129. Shortest Path with Alternating Colors
交替的`bfs`，记录当前的颜色
# 1130. Minimum Cost Tree From Leaf Values
遍历分割点求左右两边的值，类似[1039](https://github.com/humwawe/leetcode/blob/master/1001-1100.md#1039-minimum-score-triangulation-of-polygon)

另外考虑贪心的思路，每次选两个乘积的最小值，用单调栈来维护
``` java
for (int n : arr) {
    while (stack.peek() < n) ans += stack.pop() * Math.min(stack.peek(), n);
    stack.push(n);
}
while (stack.size() > 2) ans += stack.pop() * stack.peek();
```
# 1131. Maximum of Absolute Value Expression
曼哈顿距离的公式，展开绝对值，只需要将数组合并后求里面的最大值最小值相减的结果
# 1137. N-th Tribonacci Number
递推
# 1138. Alphabet Board Path
找到点的差值，注意最后一个点的位置，考虑左上右下的放下进行操作
# 1139. Largest 1-Bordered Square
记录每个点上面和左边有多少个连续的`1`，对每个点考虑能否构成正方形
# 1140. Stone Game II
记忆化递归，`dp`表示前者可以比后者多拿的差值
# 1143. Longest Common Subsequence
`dp[i][j]`，表示到`i`和到`j`的时候（可不包含）的最长公共前缀
``` java
for(int i = 1; i<=m; i++){
    for(int j = 1; j<=n; j++){
        if(text1.charAt(i-1) == text2.charAt(j-1)){
            dp[i][j] = dp[i-1][j-1] + 1;
        }else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
        }
    }
}
```
# 1144. Decrease Elements To Make Array Zigzag
分别考虑奇数位置和偶数位置比两边小的情况，端点特殊考虑
# 1145. Binary Tree Coloring Game
统计左右子树的个数，判断选某个点是否能比一号选手多
# 1146. Snapshot Array
每个位置使用`treeMap`存储
# 1147. Longest Chunked Palindrome Decomposition
找左右两边相等的情况，再递归求中间
>贪心的找到第一个相等的即是最大的分割